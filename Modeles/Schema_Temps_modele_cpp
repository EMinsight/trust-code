//////////////////////////////////////////////////////////////////////////////
//
// File:	NOM_DU_FICHIER.cpp
// Directory:	$TRUST_ROOT/NOM_DU_MODULE
//
//////////////////////////////////////////////////////////////////////////////

#include <NOM_DU_FICHIER.h>
#include <Nom.h>
#include <Equation.h>
#include <Champ_Inc.h>
#include <DoubleTrav.h>

implemente_instanciable(NOM_DE_LA_CLASSE,
                        "NOM_DE_LA_CLASSE",
                        Schema_Temps_base)

// printOn et readOn 
   
Sortie& NOM_DE_LA_CLASSE::printOn(Sortie& s) const {
   return  Schema_Temps_base::printOn(s);
}

//// readOn
//

Entree& NOM_DE_LA_CLASSE::readOn(Entree& s) {
    return Schema_Temps_base::readOn(s) ;
}

int NOM_DE_LA_CLASSE::nb_valeurs_temporelles() const
{
   // A MODIFIER nb_valeurs_temporelles est egal au nombre de
   // niveaux de temps impliques dans le schema
   return 2;
}

int NOM_DE_LA_CLASSE::faire_un_pas_de_temps_eqn_base(Equation_base& eq)
{ 
    // EXEMPLE POUR UN SCHEMA EXPLICITE UTILISANT U(n) et U(n+1)
    // Un+1=Un+dt*F
    //  Un
    DoubleTab& present = eq.inconnue().valeurs();
    
    // Un+1
    DoubleTab& futur = eq.inconnue().futur();
    
    // Un+1=F
    eq.derivee_en_temps_inco(futur);
    
    // Evaluation de l'accroisement max :
    double accroissement_max_abs=futur.max_abs();
    stationnaire_atteint_ *= ( accroissement_max_abs < seuil_statio_ );
    
    // ECRIRE ICI LE CALCUL de U(n+1) EN FONCTION DE U(n) ET DE derivee    
    // futur*=dt_; Un+1=dt*F
    // futur+=present; Un+1=Un+dt*F
    // SI IL S'AGISSAIT D'UN SCHEMA QUI FAIT INTERVENIR U(n-1)
    // DoubleTab& passe = eq.inconnue().passe();
    // SI IL S'AGISSAIT D'UN SCHEMA QUI FAIT INTERVENIR U(n-2)
    // DoubleTab& passe2 = eq.inconnue().passe(2);
    
    return 1;
   
}

