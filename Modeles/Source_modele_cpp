//////////////////////////////////////////////////////////////////////////////
//
// File:	NOM_DU_FICHIER.cpp
// Directory:	$TRUST_ROOT/Noyau
//
///////////////////////////////////////////////////////////////////////////////


#include <NOM_DU_FICHIER.h>
#include <Champ_Unif.h>
#include <Zone_dis.h>
#include <Zone_Cl_dis.h>
#include <Zone_LA_DISCRETISATION.h>
#include <Zone_Cl_LA_DISCRETISATION.h>
#include <Les_Cl.h>

implemente_instanciable(NOM_DE_LA_CLASSE,"NOM_DE_LA_CLASSE",Source_base)

//// printOn
//

Sortie& NOM_DE_LA_CLASSE::printOn(Sortie& s ) const {
   return s << que_suis_je() ;
}


//// readOn
//

Entree& NOM_DE_LA_CLASSE::readOn(Entree& s ) 
{  
   s >> la_source;
   if (la_source->nb_comp() != dimension)
   {
      Cerr << "Erreur a la lecture du terme source de type " << que_suis_je() << finl;
      Cerr << "le champ source doit avoir " << dimension << " composantes" << finl;
      exit(-1);
   }   
   return s ;
}

void NOM_DE_LA_CLASSE::associer_pb(const Probleme_base& )
{
   ;
}

void NOM_DE_LA_CLASSE::associer_zones(const Zone_dis& zone_dis,
							const Zone_Cl_dis& zone_Cl_dis)
{
   la_zone_LA_DISCRETISATION = ref_cast(Zone_LA_DISCRETISATION, zone_dis.valeur());
   la_zone_Cl_LA_DISCRETISATION = ref_cast(Zone_Cl_LA_DISCRETISATION, zone_Cl_dis.valeur());
}


DoubleTab& NOM_DE_LA_CLASSE::ajouter(DoubleTab& resu) const
{
   const Zone_LA_DISCRETISATION& zone_LA_DISCRETISATION = la_zone_LA_DISCRETISATION.valeur();
   const Zone_Cl_LA_DISCRETISATION& zone_Cl_LA_DISCRETISATION = la_zone_Cl_LA_DISCRETISATION.valeur();
   const IntTab& face_voisins = zone_LA_DISCRETISATION.face_voisins();
   const IntVect& orientation = zone_LA_DISCRETISATION.orientation();
   const DoubleTab& xv = zone_LA_DISCRETISATION.xv();
   const DoubleVect& porosite_surf = zone_LA_DISCRETISATION.porosite_face();
   const DoubleVect& volumes_entrelaces = zone_LA_DISCRETISATION.volumes_entrelaces();

   int ndeb,nfin,ncomp,num_face,elem1,elem2;
   double vol,resu_face=0.;

   if (sub_type(Champ_Uniforme,la_source.valeur()))
   {  
      const DoubleVect& s = la_source->valeurs();
      
      // Boucle sur les conditions limites pour traiter les faces de bord
      
      for (int n_bord=0; n_bord<zone_LA_DISCRETISATION.nb_front_Cl(); n_bord++)
      {
	 
	 // pour chaque Condition Limite on regarde son type
	 // Si face de Dirichlet ou de Symetrie on ne fait rien
	 // Si face de Neumann on calcule la contribution au terme source 
	 
	 const Cond_lim& la_cl = zone_Cl_LA_DISCRETISATION.les_conditions_limites(n_bord);   
	 
	 if (sub_type(Neumann_sortie_libre,la_cl.valeur())) 
	 {
	    
	    const Neumann_sortie_libre& la_cl_neumann = ref_cast(Neumann_sortie_libre,la_cl.valeur());
	    const Front_VF& le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());
	    ndeb = le_bord.num_premiere_face();
	    nfin = ndeb + le_bord.nb_faces();
	    
	    for (num_face=ndeb; num_face<nfin; num_face++) 
	    {
	       vol = volumes_entrelaces(num_face)*porosite_surf(num_face);
	       ncomp = orientation(num_face);
	       /////////////////////////////////////////////////
	       // calcul du terme source sur la face. Exemple : 
	       /////////////////////////////////////////////////
	       // resu_face=s(ncomp)*vol;
	       resu(num_face)+= resu_face;
	    }    
	    
	 }
	 else if (same_type(Symetrie,la_cl.valeur()))
	    ;
         else if ( (sub_type(Dirichlet,la_cl.valeur())) 
	    || 
	    (sub_type(Dirichlet_homogene,la_cl.valeur())) 
	    )
            ;
      }
      
      
      // Boucle sur les faces internes
      
      ndeb = zone_LA_DISCRETISATION.premiere_face_int();
      for (num_face =zone_LA_DISCRETISATION.premiere_face_int(); num_face<zone_LA_DISCRETISATION.nb_faces(); num_face++)
      {
	 vol = volumes_entrelaces(num_face)*porosite_surf(num_face);
	 ncomp = orientation(num_face);
	 /////////////////////////////////////////////////
	 // calcul du terme source sur la face. Exemple : 
	 /////////////////////////////////////////////////
	 // resu_face=s(ncomp)*vol;	 
	 resu(num_face) += resu_face;
	 
      }
   }
   else // le champ source n'est plus uniforme
   {
     const DoubleTab& s = la_source->valeurs();
      
      // Boucle sur les conditions limites pour traiter les faces de bord
      
      for (int n_bord=0; n_bord<zone_LA_DISCRETISATION.nb_front_Cl(); n_bord++) {
	 
	 // pour chaque Condition Limite on regarde son type
	 // Si face de Dirichlet ou de Symetrie on ne fait rien
	 // Si face de Neumann on calcule la contribution au terme source 
	 
	 const Cond_lim& la_cl = zone_Cl_LA_DISCRETISATION.les_conditions_limites(n_bord);   
	 
	 if (sub_type(Neumann_sortie_libre,la_cl.valeur())) 
	 {
	    
	    const Neumann_sortie_libre& la_cl_neumann = ref_cast(Neumann_sortie_libre,la_cl.valeur());
	    const Front_VF& le_bord = ref_cast(Front_VF,la_cl.frontiere_dis());
	    ndeb = le_bord.num_premiere_face();
	    nfin = ndeb + le_bord.nb_faces();
	    
	    for (num_face=ndeb; num_face<nfin; num_face++) 
	    {
	       vol = volumes_entrelaces(num_face)*porosite_surf(num_face);
	       ncomp = orientation(num_face);
	       elem1 = face_voisins(num_face,0);
	       
	       if (elem1 != -1)
	       {
		  /////////////////////////////////////////////////
		  // calcul du terme source sur la face. Exemple : 
		  /////////////////////////////////////////////////
		  // resu_face=s(elem1,ncomp)*vol;	 
		  resu(num_face)+= resu_face;
	       }
	       else
	       {
		  elem2 = face_voisins(num_face,1);
		  /////////////////////////////////////////////////
		  // calcul du terme source sur la face. Exemple : 
		  /////////////////////////////////////////////////
		  // resu_face=s(elem2,ncomp)*vol;	 
		  resu(num_face)+= resu_face;
	       }     
	    }    
	    
	 }
	 else if (same_type(Symetrie,la_cl.valeur()))
	    ;
         else if ( (sub_type(Dirichlet,la_cl.valeur())) 
	    || 
	    (sub_type(Dirichlet_homogene,la_cl.valeur())) 
	    )
      ;
      }
      
      
      // Boucle sur les faces internes
      
      double s_face;
      ndeb = zone_LA_DISCRETISATION.premiere_face_int();
      for (num_face =zone_LA_DISCRETISATION.premiere_face_int(); num_face<zone_LA_DISCRETISATION.nb_faces(); num_face++)
      {
	 
	 vol = volumes_entrelaces(num_face)*porosite_surf(num_face);
	 ncomp = orientation(num_face);
	 /////////////////////////////////////////////////
	 // calcul du terme source sur la face. Exemple : 
	 /////////////////////////////////////////////////
	 // resu_face=0.5*( s(face_voisins(num_face,0),ncomp) + s(face_voisins(num_face,1),ncomp) )*vol;	 
	 resu(num_face)+= resu_face;
	 
      }   
   }  
   return resu;
}

DoubleTab& NOM_DE_LA_CLASSE::calculer(DoubleTab& resu) const
{
   resu = 0;
   return ajouter(resu);
}

void NOM_DE_LA_CLASSE::mettre_a_jour(double temps)
{
   la_source->mettre_a_jour(temps);
}
