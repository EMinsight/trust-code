#Pmacro implementePb(__typeTrio__,__type__)
#include <__typeTrio__.h>
#include <Probleme_U.h>
#include <Exceptions.h>
#include <Noms.h>
#include <stdlib.h>
#include <Comm_Group_MPI.h>
#include <MAIN.h>
#include <mon_main.h>
#include <ICoCoTrioField.h>

#include <Init_Params.h>

#include <Motcle.h>
#include <ICoCoMEDField.hxx>
#include <Convert_ICoCoTrioField.h>
#include <stat_counters.h>

using ICoCo::__type__;
using ICoCo::__typeTrio__;
using ICoCo::TrioField;
using std::string;
using std::vector;


__typeTrio__::~__typeTrio__()
{
  if(p) delete p;
  p=0;
  delete (my_params);
}

////////////////////////////
//                        //
//   interface __typeTrio__    //
//                        //
////////////////////////////

// When the dynamic library is loaded via dlopen(), getting a handle
// on this function is the only way to create a __type__ object.

extern "C" __type__* get__type__()
{
  //Cerr<<"coucou get__type__"<<finl;
  __type__* T=new __typeTrio__;
  return T;
}

// Description:
// As initialize doesn't have any arguments, they can be passed to the __type__
// at the time of instantiation.
// They can include data file name, MPI communicator,..
// In this implementation (for use outside TRUST), only the name of an
// underlying Probleme_U needs to be provided.
// Precondition: None.
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// __type__ instantiated

__typeTrio__::__typeTrio__()
{
  my_params=new Init_Params;
  (*my_params).problem_name="default_vvvvv";
  (*my_params).problem_name="pb";
  //my_params.comm=MPI_COMM_WORLD;
  (*my_params).is_mpi=0;
  pb=NULL;
  p=NULL;
}


void __typeTrio__::setDataFile(const string& file)
{
  (*my_params).data_file=file;
}
void __typeTrio__::setMPIComm(void* mpicomm)
{
#ifdef MPI_
  if (mpicomm)
    {
      (*my_params).is_mpi=1;
      (*my_params).comm=*((MPI_Comm*)(mpicomm));
    }
#endif
}
// Description:
// This method is called once at the beginning, before any other one of
// the interface __type__.
// Precondition: __type__ is instantiated, not initialized
// (*my_params) have been filled by constructor.
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// __type__ initialized.
// Unknown and given fields are initialized at initial time
bool __typeTrio__::initialize()
{
  Process::exception_sur_exit=1;
  if (((*my_params).problem_name=="default_vvvvv") || ((*my_params).data_file=="default_vvvvv"))
    throw WrongArgument("??","Constructor","data","data shoud point to the name of a Probleme_U");

#ifdef MPI_
  // exception if I don't belong to comm !
  True_int rank_in_comm=0;
  if ((*my_params).is_mpi!=0)
    {
      if (MPI_Comm_rank((*my_params).comm,&rank_in_comm)!=MPI_SUCCESS)
        throw WrongArgument((*my_params).problem_name,"initialize","comm","This process should belong to comm");
      if (rank_in_comm==MPI_UNDEFINED)
        throw WrongArgument((*my_params).problem_name,"initialize","comm","This process should belong to comm");

      Comm_Group_MPI::set_trio_u_world((*my_params).comm);

    }
  Comm_Group_MPI::set_must_mpi_initialize(0); // ???
#endif
  int argc=2;
  char** argv=new char*[argc];
  string code="TRUST wrapper";
  // Les copies sont necessaires pour se debarrasser des const...
  argv[0]=new char[code.length()+1];
  strcpy(argv[0],code.c_str());
  argv[1]=new char[(*my_params).data_file.length()+1];
  strcpy(argv[1],(*my_params).data_file.c_str());
  // pour salome
  if (p) delete p;
  p=NULL;
  int res;
  // on lance avec ou sans mpi
  res=main_TRUST(argc,argv,p,(*my_params).is_mpi);


  delete [] argv[0];
  delete [] argv[1];
  delete [] argv;

  Nom nom("ICoCoProblemName"),nom_pb;
  if (nom.interprete().objet_existant(nom))
    {
      nom_pb=ref_cast(Nom,get_obj(nom));
      Cout<<finl<<" ICoCoProblemName from data file "<<nom_pb<< finl;
    }
  else
    {
      nom_pb="pb";
      Cout<<finl<<" ICoCoProblemName not found in data file, we try "<<nom_pb<< finl;
    }

  (*my_params).problem_name=nom_pb;
  pb=&ref_cast(Probleme_U,get_obj(nom_pb));
  if (res || !pb)
    throw WrongArgument((*my_params).problem_name,"initialize","problem_name","No problem of that name found in data file");
  initialize_pb(*pb);
  // Print the initialization CPU statistics
  if (!Objet_U::disable_TU)
    {
      statistiques().dump("Statistiques d'initialisation du calcul", 0);
      print_statistics_analyse("Statistiques d'initialisation du calcul", 0);
    }
  statistiques().reset_counters();
  statistiques().begin_count(temps_total_execution_counter_);
  return true;
}
bool __typeTrio__::initialize_pb(Probleme_U& pb_to_solve)
{
  if (pb==NULL)
    pb=&pb_to_solve;
  pb_to_solve.initialize();
  pb_to_solve.postraiter(1);
  return true;
}

// Description:
// This method is called once at the end, after any other one.
// It frees the memory and saves anything that needs to be saved.
// Precondition: initialize, but not yet terminate
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// The object is ready to be destroyed.
void __typeTrio__::terminate()
{
  pb->postraiter(1);
  pb->terminate();
  int mode_append=1;
  if (!Objet_U::disable_TU)
    {
      statistiques().dump("Statistiques Resolution", mode_append);
      print_statistics_analyse("Statistiques Resolution", 1);
    }
  if(p)
    {
      delete p;
      p=0;
      // fait dans mon_main maintenant // PE_Groups::finalize();
    }
}


///////////////////////////////////
//                               //
//   interface Unsteady__type__   //
//                               //
///////////////////////////////////


// Description:
// Returns the present time.
// This value may change only at the call of validateTimeStep.
// A surcharger
// Precondition: initialize, not yet terminate
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: double
//    Signification: present time
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// __typeTrio__ unchanged
double __typeTrio__::presentTime() const
{
  return pb->presentTime();
}

// Description:
// Compute the value the __type__ would like for the next time step.
// This value will not necessarily be used at the call of initTimeStep,
// but it is a hint.
// This method may use all the internal state of the __type__.
// Precondition: initialize, not yet terminate
// Parametre: stop
//    Signification: Does the __type__ want to stop ?
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: double
//    Signification: The desired time step
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// __typeTrio__ unchanged
double __typeTrio__::computeTimeStep(bool& stop) const
{
  return pb->computeTimeStep(stop);
}


// Description:
// This method allocates and initializes the unknown and given fields
// for the future time step.
// The value of the interval is imposed through the parameter dt.
// In case of error, returns false.
// Precondition: initialize, not yet terminate, timestep not yet initialized, dt>0
// Parametre: double dt
//    Signification: the time interval to allocate
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: bool
//    Signification: true=OK, false=error, not able to tackle this dt
//    Contraintes:
// Exception: WrongContext, WrongArgument
// Effets de bord:
// Postcondition:
// Enables the call to several methods for the next time step
bool __typeTrio__::initTimeStep(double dt)
{
  return pb->initTimeStep(dt);
}


// Description:
// Calculates the unknown fields for the next time step.
// The default implementation uses iterations.
// Precondition: initTimeStep
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: bool
//    Signification: true=OK, false=unable to find the solution.
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// The unknowns are updated over the next time step.
bool __typeTrio__::solveTimeStep()
{
  statistiques().begin_count(timestep_counter_);
  if (pb->lsauv())
    pb->sauver();
  bool res=pb->solveTimeStep();

  return res;
}


// Description:
// Validates the calculated unknown by moving the present time
// at the end of the time step.
// This method is allowed to free past values of the unknown and given
// fields.
// Precondition: initTimeStep
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// The present time has moved forward.
void __typeTrio__::validateTimeStep()
{
  pb->validateTimeStep();
  pb->postraiter(0);
  statistiques().end_count(timestep_counter_);
}

// Description:
// Tells if the __type__ unknowns have changed during the last time step.
// Precondition: validateTimeStep
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: bool
//    Signification: true=stationary, false=not stationary
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// __typeTrio__ unchanged
bool __typeTrio__::isStationary() const
{
  return pb->isStationary();
}

// Description:
// Aborts the resolution of the current time step.
// Precondition: initTimeStep
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// Can call again initTimeStep with a new dt.
void __typeTrio__::abortTimeStep()
{
  pb->abortTimeStep();
}

/////////////////////////////////////////////
//                                         //
//   interface IterativeUnsteady__type__    //
//                                         //
/////////////////////////////////////////////

// Description:
// In the case solveTimeStep uses an iterative process,
// this method executes a single iteration.
// It is thus possible to modify the given fields between iterations.
// converged is set to true if the process has converged, ie if the
// unknown fields are solution to the problem on the next time step.
// Otherwise converged is set to false.
// The return value indicates if the convergence process behaves normally.
// If false, the __typeTrio__ wishes to abort the time step resolution.
// Precondition: initTimeStep
// Parametre: bool& converged
//    Signification: It is a return value :
//                   true if the process has converged, false otherwise.
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: bool
//    Signification: true=OK, false=unable to converge
//    Contraintes:
// Exception: WrongContext
// Effets de bord:
// Postcondition:
// The unknowns are updated over the next time step.
bool __typeTrio__::iterateTimeStep(bool& converged)
{
  return pb->iterateTimeStep(converged);
}

// Description:
// This method is used to find the names of input fields understood by the __type__
// Precondition: initTimeStep
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: vector<string>
//    Signification: list of names usable with getInputFieldTemplate and setInputField
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
// __typeTrio__ unchanged
vector<string> __typeTrio__::getInputFieldsNames() const
{
  vector<string> v;
  Noms noms;
  pb->getInputFieldsNames(noms);
  for (int i=0; i<noms.size(); i++)
    v.push_back(noms[i].getChar());
  return v;
}

// Description:
// This method is used to get a template of a field expected for the given name.
// Precondition: initTimeStep, name is one of getInputFieldsNames
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
// afield contains a field with values neither allocated nor filled, describing the
// field expected by setInputField for that name.
// __typeTrio__ unchanged
void __typeTrio__::getInputFieldTemplate(const std::string& name, TrioField& afield) const
{
  Nom nom(name.c_str());
  pb->getInputFieldTemplate(nom,afield);
}

// Description:
// This method is used to provide the __type__ with an input field.
// Precondition: initTimeStep, name is one of getInputFieldsNames, afield is like in getInputFieldTemplate
// Parametre:
//    Signification:
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour:
//    Signification:
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
// Values of afield have been used (copied inside the __typeTrio__).
void __typeTrio__::setInputField(const std::string& name, const TrioField& afield)
{
  Nom nom(name.c_str());
  pb->setInputField(nom,afield);
}


vector<string> __typeTrio__::getOutputFieldsNames() const
{

  // const __type__e_base& pb_base=ref_cast(__type__e_base,*pb);
  Noms my_names;
  pb->getOutputFieldsNames(my_names);
  vector<string> output_names;
  for (int i=0; i<my_names.size(); i++)
    output_names.push_back(my_names(i).getChar());
  return  output_names;

}


void __typeTrio__::getOutputField(const std::string& name_, TrioField& afield) const
{
  Motcle name(name_.c_str());
  pb->getOutputField(name,afield);
}

#Pif("__type__"=="Problem")
#ifdef OLD_MEDCOUPLING
ParaMEDMEM::MEDCouplingFieldDouble* __typeTrio__::getOutputMEDField(const string& name) const
{
#ifndef NO_MEDFIELD
  TrioField  triofield;
  getOutputField(name,triofield);
  MEDField medfield= build_medfield(triofield);
  ParaMEDMEM::MEDCouplingFieldDouble*  field=medfield.getField();
  field->incrRef();
  //delete medfield;
  return field;
#else
  throw NotImplemented("No ParaMEDMEM","getInputMEDField");
#endif
}
ParaMEDMEM::MEDCouplingFieldDouble* __typeTrio__::getInputMEDFieldTemplate(const std::string& name) const
{
#ifndef NO_MEDFIELD
  TrioField  triofield;
  getInputFieldTemplate(name,triofield);
  MEDField medfield=build_medfield(triofield);
  ParaMEDMEM::MEDCouplingFieldDouble*  field=medfield.getField();
  field->incrRef();
  //delete medfield;
  return field;

#else
  throw NotImplemented("No ParaMEDMEM","getInputMEDFieldTemplate");
#endif
}

void __typeTrio__::setInputMEDField(const std::string& name, const ParaMEDMEM::MEDCouplingFieldDouble* afield)
{
#ifndef NO_MEDFIELD
  // bof en attendant mieux
  TrioField  triofield;
  getInputFieldTemplate(name,triofield);

  const ParaMEDMEM::DataArrayDouble *fieldArr=afield->getArray();
  triofield._field=const_cast<double*> (fieldArr->getConstPointer());
  // il faut copier les valeurs
  setInputField(name,triofield);
  triofield._field=0;
  //fieldArr->decrRef();
#else
  throw NotImplemented("No ParaMEDMEM","setInputMEDField");
#endif
}

#endif
#Pendif
void __typeTrio__::getOutputField(const std::string& name,MEDField& medfield) const
{
#ifndef NO_MEDFIELD
  TrioField  triofield;
  getOutputField(name,triofield);
  medfield= build_medfield(triofield);

#else
  throw NotImplemented("No ParaMEDMEM","getInputMEDField");
#endif
}
void __typeTrio__::getInputFieldTemplate(const std::string& name, MEDField& medfield) const
{
#ifndef NO_MEDFIELD
  TrioField  triofield;
  getInputFieldTemplate(name,triofield);
  medfield=build_medfield(triofield);
#else
  throw NotImplemented("No ParaMEDMEM","getInputMEDFieldTemplate");
#endif
}

void __typeTrio__::setInputField(const std::string& name, const MEDField& afield)
{
#ifndef NO_MEDFIELD
  // bof en attendant mieux
  TrioField  triofield;
  getInputFieldTemplate(name,triofield);
#Pif("__type__"=="Problem")
#ifdef OLD_MEDCOUPLING
  const ParaMEDMEM::DataArrayDouble *fieldArr=afield.getField()->getArray();
#else
  const MEDCoupling::DataArrayDouble *fieldArr=afield.getField()->getArray();
#endif
#Pelse
  const MEDCoupling::DataArrayDouble *fieldArr=afield.getField()->getArray();
#Pendif
  triofield._field=const_cast<double*> (fieldArr->getConstPointer());
  // il faut copier les valeurs
  setInputField(name,triofield);
  triofield._field=0;
  //fieldArr->decrRef();

#else
  throw NotImplemented("No ParaMEDMEM","setInputMEDField");
#endif
}


#Pif ("__type__"=="Problem")
// Miscellaneous
Objet_U& get_obj(const char* chr)
{
  Nom nom(chr);
  Objet_U& obj=nom.interprete().objet(nom);
  return obj;
}
#Pendif

#Pendmacro(implementePb)
