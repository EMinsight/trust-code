#!/bin/bash
## a little wrapper to "password" and re-launch a shell-listener.
## Arg is taken as the port to listen on.  Define "NC" to point wherever.
## Attention, pb pour http://localhost si proxy mal configure !
NC=$TRUST_ROOT/exec/netcat
[ ! -f $NC ] && echo "$NC inexistant." && exit
case "$1" in
  ?* )
  LPN="$1"
  export LPN
  sleep 1
  # Test de netcat !
  [ "`$NC -v 2>&1`" != "no destination" ] && echo "Trouble with netcat... You should may me recompile it."
  # On efface car pb rencontre sur une sun au LETI:
  rm -f $TRUST_TMP/netcat.out
  echo "-l -p $LPN -e $0" | $NC 1>$TRUST_TMP/netcat.out 2>&1 &
  echo $! > $TRUST_TMP/.netcat
  echo "launched on port $LPN"
  exit 0
  ;;
esac

# here we play inetd
echo "-l -p $LPN -e $0" | $NC > /dev/null 2>&1 &
echo $! > $TRUST_TMP/.netcat
read qq
echo $qq > $TRUST_TMP/.server
#echo $QUERY_STRING >> $HOME/.err
#echo $HTTP_COOKIE >> $HOME/.err
case $qq in
  # GET /path/ HTTP/1.0
  # Recupere la deuxieme chaine
  # Ne pas utiliser ../../ car netcat tronque les .. !
  GET*) chaine=`echo $qq | cut -d" " -f2`
        script=`echo $chaine | cut -d"?" -f1`
        args=${chaine#$script?}
        type=`echo $script | cut -d"." -f2`
        case $type in
        	cg) $TRUST_ROOT/bin/CGI$script $args;;
		html) $TRUST_ROOT/bin/CGI/index.cg ${script#\/};;
		gif) ;;
        	*) echo "Type $type non reconnu: $qq"
        esac
  exit
  ;;
esac

