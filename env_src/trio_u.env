#!/bin/bash
#
# Variables d'environnement TRUST
#
# (22/11/05): Nouveau, pour eviter que les variables d'environnement en particulier, PATH,
# soient tres longues, on ajoute un repertoire que s'il existe et s'il n'est pas deja dans le PATH
# en premiere place
ADD_PATH()
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $PATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export PATH=$1:$PATH
}
ADD_LD_LIBRARY_PATH()
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $LD_LIBRARY_PATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export LD_LIBRARY_PATH=$1:$LD_LIBRARY_PATH
}
ADD_MANPATH()
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $MANPATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export MANPATH=$1:$MANPATH
}
ADD_LD_LIBRARY64_PATH()
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $LD_LIBRARY64_PATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export LD_LIBRARY64_PATH=$1:$LD_LIBRARY64_PATH
}
ADD_SHLIB_PATH() 
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $SHLIB_PATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export SHLIB_PATH=$1:$SHLIB_PATH
}
ADD_LIBPATH()
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $LIBPATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export LIBPATH=$1:$LIBPATH
}
ADD_PYTHONPATH()
{
   [ $CHANGE_ENV = 1 ] || [ "`echo $PYTHONPATH | grep $1:`" = "" ] && [ ${#1} != 0 ] && [ -d $1 ] && export PYTHONPATH=$1:$PYTHONPATH
}

# Variable pour savoir s'il est necessaire de changer l'environnement (IMPORTANT si l'on fait
# des allers retours d'un environnement a l'autre...):
CHANGE_ENV=0 && [ "`type Init_TRUST 2>&1 | awk '{gsub("/env/Init_TRUST","",$NF);print $NF}'`" != $TRUST_ROOT ] && CHANGE_ENV=1
#Recursif parfois:
#CHANGE_ENV=0 && [ "`Init_TRUST -version 2>/dev/null | grep TRUST_ROOT`" != "TRUST_ROOT=$TRUST_ROOT" ] && CHANGE_ENV=1
#echo $PATH | awk '{split($0,a,":");for (i in a) print a[i]}'

#####################################
# Variables dependant de la machine :
#####################################
if [ ! -f $TRUST_ROOT/env/machine.env ]
then
   echo
   echo "\$TRUST_ROOT/env/machine.env not found!"
   echo "You must run ./configure under \$TRUST_ROOT"
   # Ne surtout pas faire exit car sinon on quitte le terminal
   # et parfois on ne peut plus se logger sur un compte ou
   # l'environnement TRUST est initialise
   #exit 
else
   . $TRUST_ROOT/env/machine.env
   export OPT="_opt"               # "_opt" optimisee -O3 ou "" debug -g
   # Detect TRUST_NB_PROCS dynamically:
   export TRUST_NB_PROCS=`$TRUST_ROOT/env/configurer_env -TRUST_NB_PROCS`
   export TRUST_MAKE="make -j $TRUST_NB_PROCS"  
 
   # Variables d'environnement pour MPI
   if [ "$COMM" = _mpi ]
   then
      if [ $TRUST_ARCH = SGI ]
      then
         # Valeurs taille des messages sur SGI (a augmenter si necessaire ...)
         # Mieux si blocage a Traitement des images joints (par defaut 16):
         export MPI_BUFS_PER_HOST=1000
         export MPI_BUFS_PER_PROC=1000
         # Variables suivantes necessaires car sinon message sur SGI (Obstacle):
         # *** MPI has run out of PER_PROC message headers.
         # *** The current allocation levels are:
         # ***     MPI_MSGS_PER_HOST = 0
         export MPI_MSGS_PER_PROC=32768 
         export MPI_MSGS_PER_HOST=32768 
         # Nouveau depuis le changement du // entre v1.3.1 et v1.3.2 #
         export MPI_REQUEST_MAX=100000
         # Car sinon message suivant sur certains cas:
         # *** MPI has run out of request entries. 
	 # *** The current allocation level is: 
	 # ***     MPI_REQUEST_MAX = 1024 
      elif [ $TRUST_ARCH = DECalpha ]
      then
         # pour ixia (a tester):
         export LIBELAN_TPORT_BIGMSG=4304
      fi
      # MPIBULL2
      if [ "`env | grep MPIBULL2`" != "" ]
      then
	 export MPIBULL2_USE_POSTAL=1 # Optimise (fortement) les communications intra-noeuds
	 export MPIBULL2_USE_POSTAL=0 # En attendant que MPIBULL2 fonctionne bien
      fi
   fi
   # Nettoyage des repertoires temporaires d'OpenMpi car sinon
   # risque de blocage, lenteurs ou plantages (a deplacer dans mpirun)
   who=`whoami`
   for rep in ~/tmp /tmp $TRUST_TMP
   do
      if [ -d $rep ]
      then
	 for session in `ls $rep | grep openmpi-sessions-$who`
	 do
            cd $rep/$session
	    # On ne garde que les 30 repertoires les plus recents
	    nb_dir=`ls -rt | wc -w | awk '{print $1-30}'`
	    if [ $nb_dir -gt 0 ]
	    then
  	       for dir in `ls -rt | head -$nb_dir 2>/dev/null`
	       do
		  [ -f $dir/contact.txt ] && rm -r -f $dir 
	       done
	    fi
	    cd - 1>/dev/null 2>&1
	 done
      fi
   done
   if [ "$MPI_ROOT" != "" ]
   then
      ADD_PATH $MPI_ROOT/bin
      ADD_MANPATH $MPI_ROOT/man 
      ADD_MANPATH $MPI_ROOT/share/man
      ADD_LD_LIBRARY_PATH $MPI_ROOT/`\ls $MPI_ROOT | grep lib`
   fi

   [ ${#Mpirun} != 0 ] && [ "$Mpirun" = $TRUST_ROOT/bin/mpirun ] && echo "Problem, Mpirun variable could not match $TRUST_ROOT/bin/mpirun ..." && eval $FIN

   # Valgrind (options minimales pour valgrind 2.0.0 ...) Pour 2.2.0, ca crashe !
   VALGRIND_OPTS="" && [ "`valgrind --version 2>/dev/null`" = valgrind-2.0.0 ] && export VALGRIND_OPTS="-v --num-callers=15 --leak-check=yes --show-reachable=yes"

   
   ##############################################################################
   # Pour VisIt, GNU 4.0.1 a LD_LIBRARY_PATH mal fixe par defaut (/usr/X11R6/lib) 
   # et la libGL.so.1 n'est pas la bonne semble t'il et "visit -nowin" crashe
   # peyrolle:/work/triou > ls -lart /usr/X11R6/lib/libGL.so.1
   # lrwxrwxrwx  1 root root 21 jan 20  2010 /usr/X11R6/lib/libGL.so.1 -> libGLwrapper.so.0.2.0*
   # Alors qu'il faut utiliser:
   # peyrolle:/work/triou > ls -lart /usr/lib/libGL.so.1
   # lrwxrwxrwx  1 root root 27 jan 20  2010 /usr/lib/libGL.so.1 -> /usr/X11R6/lib/libGL.so.1.2
   # En esperant que cela n'est pas d'effet de bord...
   ###################################################
   [ "$TRUST_VERSION_GNU" = 4.0.1 ] && ADD_LD_LIBRARY_PATH /usr/lib
fi

#############################
# Choix pour la variable exec
#############################
export exec_debug=$TRUST_ROOT/exec/TRUST$COMM
export exec_opt=$TRUST_ROOT/exec/TRUST$COMM"_opt"
export exec_pg=$TRUST_ROOT/exec/TRUST$COMM"_opt_pg"
export exec_gcov=$TRUST_ROOT/exec/TRUST$COMM"_opt_gcov"
export exec_avx=$TRUST_ROOT/exec/TRUST$COMM"_opt_avx"
export exec_semi_opt=$TRUST_ROOT/exec/TRUST$COMM"_semi_opt"
# Depuis la 164, l'exec par defaut est le binaire semi-optimise dans une vue
export exec=$exec_opt
# Semi optimized binary used if SCM:
# if [ "$TRUST_SCM" = 1 ]
# then
#    [ -f $exec_semi_opt ] && exec=$exec_semi_opt
# fi
export TRUST_LIB=$TRUST_ROOT/lib
export TRUST_ENV=$TRUST_ROOT/env
export TRUST_TESTS=$TRUST_ROOT/tests
export TRUST_VALIDATION=$TRUST_ROOT/Validation/Rapports_automatiques/Validant/Fini
unset Rapports_auto_root # Unset Baltik variable
# Some adresses:
export TRUST_PROJECT_LEADER=gauthier.fauchet@cea.fr
export TRUST_FTP=ftp.cea.fr
export TRUST_HOST_ADMIN=is226425
# GIT Repos
export TRUST_GIT_SERVER=sedna
export TRUST_GIT_OFFICIAL=git://$TRUST_GIT_SERVER:9090/official/trio_u
export TRUST_GIT_SHARED=git://$TRUST_GIT_SERVER:9090/shared/trio_u
export TRUST_GIT_REPOS=/applicatifs_dm2s/triou/GIT_REPOS/official/trio_u
[ -d $TRUST_ROOT/../.git ] && export TRUST_GIT=1
# PETSC and METIS
export PETSC_ROOT=$TRUST_LIB/src/LIBPETSC/petsc # PETSC_ROOT should be defined
# Useful for building PETSc tests but conflicts with Gmsh:
# export PETSC_DIR=$TRUST_LIB/src/LIBPETSC/petsc/$TRUST_ARCH"_opt"
if [ "$TRUST_DISABLE_PETSC" = 1 ]
then 
   export METIS_ROOT=$TRUST_LIB/src/LIBMETIS
else
   # If PETSc installed, METIS is included:
   export METIS_ROOT=$PETSC_ROOT/$TRUST_ARCH"_opt"
fi
export TRUST_LATAFILTER=$TRUST_LIB/src/LIBLATAFILTER
export TRUST_ICOCOAPI=$TRUST_LIB/src/LIBICOCOAPI
export TRUST_MED_ROOT=$TRUST_LIB/src/LIBMED/MED
export TRUST_MEDCOUPLING_ROOT=$TRUST_LIB/src/LIBMEDCOUPLING/install
export LIB_EXTENSION="a"	# "a"ou "sl" ou "so" statique ou share libs
# Attention l'ordre est important (essayer de generaliser dans le futur par exemple chercher exec/*/bin)
# for NEW_PATH in VisIt/bin bin/admin exec/valgrind/bin exec/gmake/bin exec/makedepend/bin exec/cmake/bin exec/gnuplot/bin exec/gmsh/bin bin/HTML bin/GIT bin/CLEARCASE bin/IHM bin/KSH exec bin     
# GF: ne plus mettre bin/admin dans le PATH sauf pour triou
for NEW_PATH in Outils/VisIt/bin exec/valgrind/bin exec/gmake/bin exec/makedepend/bin exec/cmake/bin exec/gnuplot/bin exec/gmsh/bin bin/HTML bin/GIT bin/CLEARCASE bin/IHM bin/KSH exec bin     
do
   ADD_PATH $TRUST_ROOT/$NEW_PATH
done
if [ "$TRUST_LOGIN" = triou ]
then
   NEW_PATH=bin/admin
   ADD_PATH $TRUST_ROOT/$NEW_PATH
fi
# On ne surcharge pas l'environnement TRUST avec le python installe car conflits possibles
#ADD_PATH $TRUST_ROOT/exec/python/bin
export TRUST_AWK=$TRUST_ROOT/bin/AWK
# Librairies
ADD_LD_LIBRARY_PATH $TRUST_LIB
#ADD_LD_LIBRARY_PATH $TRUST_ROOT/exec/python/lib
ADD_LD_LIBRARY_PATH $TRUST_ROOT/Outils/gnuplot/gd/lib
ADD_LD_LIBRARY_PATH $TRUST_ROOT/Outils/gnuplot/png/lib
ADD_LD_LIBRARY_PATH $TRUST_ROOT/Outils/gnuplot/zlib/lib
ADD_LD_LIBRARY_PATH $TRUST_ROOT/lib/src/LIBMED/MED/lib
# SGI64
ADD_LD_LIBRARY64_PATH $TRUST_LIB
# HP
ADD_SHLIB_PATH $TRUST_LIB
ADD_LIBPATH $TRUST_LIB
# Python
#ADD_PYTHONPATH chemin
# Sur certaines machines $HOME est mal defini...
[ ${#HOME} = 0 ] && export HOME=`\cd;pwd`

. $TRUST_ENV/TRUST_TMP.env
. $TRUST_ENV/IHM.env
. $TRUST_ENV/prepost.env

if [ -f $TRUST_ROOT/exec/ccache/bin/ccache ]
then
   #########################
   # Configuration de ccache
   #########################
   ADD_PATH $TRUST_ROOT/exec/ccache/bin
   ADD_MANPATH $TRUST_ROOT/exec/ccache/share/man
   # 164: Le cache est desormais partage par plusieurs versions (et on efface l'ancien cache):
   export CCACHE_VERSION=`ccache --version 2>/dev/null | head -1 | awk '{print $3}'`
      export CCACHE_DIR=$TRUST_TMP/../.ccache$CCACHE_VERSION
   export CCACHE_COMPRESS=1
   export CCACHE_LOGFILE=$TRUST_TMP/ccache.log
   # TRES IMPORTANT (sinon problemes parfois avec ccache dont systematiques avec l'atelier. Exemple: petsc_for_kernel.h vide dans l'atelier, il continue a prendre le process.o du cache !!!
   export CCACHE_NODIRECT=1
   #export CCACHE_COMPILERCHECK=content 
   # On le dimensionne a 500M
      size=500
      if [ "`ccache -s | awk '/max cache size/ {print int($4)}'`" != $size ]
      then 
         ccache -M $size"M"
      fi
   if [ "$TRUST_SHARE" != "" ] && [ "`id -g`" = 85 ] && [ -d $TRUST_SHARE ]
   then
      #########################
      # Configuration de distcc
      #########################
      # Ajout du test sur le groupe (85: triou) car sinon pas le droit d'ecriture
      # On restreint egalement au LMDL avec le test sur /work car blocage sur ceres
      if [ -f $TRUST_ROOT/exec/distcc/bin/distcc ] && [ "`id -g`" = 85 ] && [ -d $TRUST_SHARE ]
      then
         tmp=`mktemp_`
	 ADD_PATH $TRUST_ROOT/exec/distcc/bin
	 export CCACHE_PREFIX=distcc
	 # Recupere le numero de version de gcc
	 export GCC_VERSION=`$TRUST_CC --version | head -1 | $TRUST_Awk '(NF==1) {print $1} (NF!=1) {print $3}'`
	 if [ ${#GCC_VERSION} = 0 ]
	 then
            echo "Version de $TRUST_CC non reconnue ! Contacter le support TRUST."
	 elif [ "`distccd --version 2>/dev/null`" != "" ]
	 then
            machine=`hostname | $TRUST_Awk -F. '{print $1}'`
	    # On rajoute la distinction de l'OS pour distcc avec uname -m 
	    # car conflit entre gcc 4.1.1 32 bits et gcc 4.1.1 64 bits !
	    # Nouveau distcc3.x on lit dans un repertoire different pour eviter les conflits
	    # Le format de ce fichier est le suivant (nom/nb_procs)
	    # machine1/nb_procs     
	    # machine2/nb_procs     
	    # ...
	    export DISTCC_LISTE_MACHINES=$TRUST_SHARE/distcc3/distcc_$GCC_VERSION"_"`uname -m`
	    ######################
	    # Lancement de distccd
	    ######################
            if [ "$DISTCCD" = "NO" ]
	    then
	       # On tue les processes existants
	       killall distccd 2>/dev/null
	       # On supprime le nom de la liste des machines
	       cat $DISTCC_LISTE_MACHINES | grep -vw $machine > $tmp
	       cat $tmp > $DISTCC_LISTE_MACHINES
	    else
	       # Changement des options de distccd avec distcc3:
	       # -On autorise a ce que le serveur accepte $TRUST_NB_PROCS jobs
	       # -Plus de nice impose
	       # -Limite de vie du job de compilation fixe a 5s	(supprime car cela plante la compile) --job-lifetime 5       
	       distccd_options="--allow 132.168.0.0/16 --daemon --log-file=$TRUST_TMP/distccd.log -j $TRUST_NB_PROCS"
	       ecriture_config=1
	       # Est ce qu'un serveur tourne avec les bonnes options ?
	       # Est ce que le serveur tourne depuis moins de 10 jours ? (On fait le menage de temps en temps car lsdistcc ne detecte pas un serveur qui ne repond plus...)
	       if [ "`ps -efl | grep "distccd $distccd_options" | grep -v grep`" = "" ] || [ "`ps -eo cmd,etime | $TRUST_Awk '/distccd/ {print $NF}' | $TRUST_Awk -F- '/-/ && ($1>10) {print 1}'`" = 1 ]
	       then
	          echo "distcc server started on $HOSTNAME"
	          # Non dans ce cas on le tue
	          killall distccd 2>/dev/null
		  # On lance le serveur
	          distccd $distccd_options 1>/dev/null 2>&1
	          # Cela echoue si un distccd ancien tourne sur un autre login de la meme machine (failed: Address already in use)
		  if [ $? != 0 ]
		  then
	             # On supprime alors le nom de la liste des machines
	             cat $DISTCC_LISTE_MACHINES | grep -vw $machine > $tmp
	             cat $tmp > $DISTCC_LISTE_MACHINES
		     ecriture_config=0
		  fi
	       fi
	       if [ $ecriture_config = 1 ]
	       then
        	  # Ecriture de la config (eventuellement plusieurs processeurs) dans un seul fichier distcc_
        	  if [ "`grep -w $machine/$TRUST_NB_PROCS $DISTCC_LISTE_MACHINES 2>/dev/null`" = "" ]
        	  then
                     grep -v $machine $DISTCC_LISTE_MACHINES 2>/dev/null > $tmp 
      	             echo $machine/$TRUST_NB_PROCS >> $tmp
                     cat $tmp > $DISTCC_LISTE_MACHINES
        	  fi     
		  # Verification que la machine est dans un seul fichier sinon traitement
		  # Ce cas survient lorsque l'on change un compilateur sur une machine
		  distcc_files=`grep -l $machine $TRUST_SHARE/distcc3/distcc_* 2>/dev/null`
		  for distcc_file in $distcc_files
		  do
	             if [ $distcc_file != $DISTCC_LISTE_MACHINES ]
		     then
			# echo "Suppression de $machine dans le fichier $distcc_file"
	        	cat $distcc_file | grep -v $machine > $tmp
	        	cat $tmp > $distcc_file		     
		     fi
		  done
	       fi
	    fi
	    chmod g+w $DISTCC_LISTE_MACHINES 2>/dev/null
	    ######################
	    # Definition de distcc
	    ######################
	    export DISTCC_VERBOSE=0
	    export DISTCC_LOG=$TRUST_TMP/distcc.log
	    rm -f $DISTCC_LOG
            if [ "$DISTCCD" = "NO" ]
	    then
	       export DISTCC_HOSTS=""
	    else	
	       # Il est preferable que localhost soit la premiere machine citee dans $DISTCC_HOSTS   
	       # Nouveau avec distcc3.1, le randomize permet de mieux equilibrer la charge
	       export DISTCC_HOSTS="--randomize localhost/$TRUST_NB_PROCS" # On utilise pour eviter la creation d'un daemon par distccd
	       #export DISTCC_HOSTS="--randomize localhost `$TRUST_Awk -v machine=$machine -F"/" '{if ($1==machine && fait==0) {fait=1} else print $0}' $DISTCC_LISTE_MACHINES 2>/dev/null`"
	       # Nouveau distcc3.x, on est capable de detecter a l'avance les machines non accessibles avec lsdistcc
	       echo "==========================="
	       echo "Detecting compilation farm:"
	       echo "==========================="
	       MAKE_NB_CPUS=$TRUST_NB_PROCS
	       for DISTCC_HOST in `cat $DISTCC_LISTE_MACHINES 2>/dev/null`
	       do
		  machine=`echo $DISTCC_HOST | $TRUST_Awk -F"/" '{print $1}'`
		  machine_cpus=`echo $DISTCC_HOST | $TRUST_Awk -F"/" '{print $2}'`
		  echo $ECHO_OPTS "$DISTCC_HOST CPUS...\c"
		  # On ne prend que les machines accessibles avec un temps de latence nul
		  # Cela permet de filtrer un peu les machines lentes
		  latence=`lsdistcc -l $machine 2>/dev/null | awk '{print $2}'`
		  if [ "$latence" = "" ]
		  then
        	     echo KO
		     # On supprime de la liste
		     tmp=`mktemp_`
		     cat $DISTCC_LISTE_MACHINES | grep -vw $DISTCC_HOST > $tmp
		     cat $tmp > $DISTCC_LISTE_MACHINES
		     rm -f $tmp	
		  elif [ "$latence" = 0 ]
		  then
        	     echo OK
		     # Idealement, il faudrait mettre les machines les plus puissantes en tete
		     if [ $machine != $HOST ]
		     then
			DISTCC_HOSTS=$DISTCC_HOSTS" "$DISTCC_HOST
			let MAKE_NB_CPUS=$MAKE_NB_CPUS+$machine_cpus
		     fi
		     # Il est conseille de doubler (a valider)
		     # Non cela ne semble pas optimal
		     #let MAKE_NB_CPUS=$MAKE_NB_CPUS+$machine_cpus
		  else
		     echo "SLOW (latency=$latence)..."
		  fi
               done
	       export TRUST_MAKE="make -j $MAKE_NB_CPUS"
               echo TRUST_MAKE=\"$TRUST_MAKE\"
               echo DISTCC_HOSTS=\"$DISTCC_HOSTS\"	       
	       echo "============================"
	    fi
	 fi
	 rm -f $tmp
      fi
   fi
fi
######################
# Personal environment
######################
perso=$HOME/.perso_trio_u.env 
if [ ! -f $perso ]
then
   cp $TRUST_ROOT/env/perso_trio_u.env $perso 1>/dev/null 2>&1
   chmod 744 $perso 1>/dev/null 2>&1
fi
if [ -f $perso ]
then
   echo $ECHO_OPTS "Loading personal configuration $perso"
   . $perso
   $TRUST_Awk '($1=="export") {print $0}' $perso
fi

# Force la creation des coredump (on verra car ca prend de la place sur tantale !)
#ulimit -c unlimited
# Attention, forcer la limite des coredump avec ulimit -c empeche un changement ulterieur
# avec un message d'erreur du style Operation not permitted !
# Remarque au passage: les abort dans le code provoque un coredump, c'est pas tres sain
# donc d'avoir mis abort() au lieu de exit() pour faciliter le debug: il suffit de faire break exit
# dans le debugger.
# NB: assert sur veymont ou ecrins ne cree pas de coredump ! dom si !
# jungfrau: pose probleme avec Ansys
if [ $HOST != jungfrau ]
then
   if [ $HOST = $TRUST_HOST_ADMIN ] || [ $HOST = castor ]
   then
      ulimit -c unlimited 2>/dev/null
   else
      ulimit -c 0 2>/dev/null
   fi
fi

###############################################
# Verification des performances de TRUST_TMP #
###############################################
dd.ksh -speed $TRUST_TMP -silent
if [ $? != 0 ]
then
   echo "Please, specify a directory for the TRUST_TMP variable in the $perso file"
   echo "in order to have good performances for TRUST." 
fi

##################
# Configure nedit:
##################
Language_mode_TRUST.sh -no_verbose

################
# Configure vim:
################
configure_vim.sh

##################
# Configure emacs:
##################
configure_emacs.sh

####################################################################
# On verifie que l'environnement est a jour par rapport a la machine
####################################################################
$TRUST_ROOT/env/configurer_env -check
if [ $? != 0 ]
then
   for variable in `env | awk -F=  '/TRUST_/ {print $1}'`
   do
      unset $variable
   done
fi

##################################
# Initialize a quick dev directory
##################################
if [ ${#rep_dev} = 0 ]
then
   rep_dev=$HOME/atelier
   export rep_dev
fi
