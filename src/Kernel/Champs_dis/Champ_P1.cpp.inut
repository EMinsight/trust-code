#include <Champ_P1.h>
#include <Domaine.h>
#include <Zone_dis.h>

Implemente_base(Champ_P1,"Champ_P1",Champ_Inc_base);

// Description: 
//    Ecrit le type et le nom du Champ sur un flot de sortie
// Precondition: 
// Parametre: Sortie& s
//    Signification: un flot de sortie
//    Valeurs par defaut: 
//    Contraintes: 
//    Acces: entree/sortie
// Retour: Sortie& 
//    Signification: le flot de sortie modifie
//    Contraintes: 
// Exception: 
// Effets de bord: 
// Postcondition: la methode ne modifie pas l'objet 
Sortie& Champ_P1::printOn(Sortie& s) const {
  return s << que_suis_je() << " " << le_nom();
}


// Description: 
//    Lit les donnees du champ P1 a partir d'un flot d'entree.
//    Appelle Champ_Inc_base::lire_donnees(Entree&)
// Precondition: 
// Parametre: Entree& s
//    Signification: un flot d'entree
//    Valeurs par defaut: 
//    Contraintes: 
//    Acces: entree/sortie
// Retour: Entree& 
//    Signification: le flot d'entree modifie
//    Contraintes: 
// Exception: 
// Effets de bord: 
// Postcondition: 
Entree& Champ_P1::readOn(Entree& s) {
  lire_donnees(s) ;
  return s ;
}

DoubleTab& Champ_P1::remplir_coord_noeuds(DoubleTab& noeuds) const
{

  noeuds.ref(zone_dis_base().zone().domaine().coord_sommets());
  return noeuds;
}

// Description: 
//    Renvoie les valeurs du champ aux points specifies
//    par leurs coordonnees, en indiquant que les points de
//    calculs sont situes dans les elements indiques.
// Precondition: 
// Parametre: DoubleTab& positions
//    Signification: le tableau des coordonnees des points de calcul
//    Valeurs par defaut: 
//    Contraintes: reference constante
//    Acces: entree
// Parametre: IntVect& les_polys
//    Signification: le tableau des elements dans lesquels sont
//                   situes les points de calcul
//    Valeurs par defaut: 
//    Contraintes: reference constante
//    Acces: entree
// Parametre: DoubleTab& val
//    Signification: le tableau des valeurs du champ aux points specifies
//    Valeurs par defaut: 
//    Contraintes: 
//    Acces: entree/sortie
// Retour: DoubleTab& 
//    Signification: le tableau des valeurs du champ aux points specifies
//    Contraintes: 
// Exception: le tableau des valeurs a plus de 2 entrees (rang >2)
// Effets de bord: 
// Postcondition: la methode ne modifie pas l'objet 
DoubleTab& Champ_P1::valeur_aux_elems(const DoubleTab& positions,
                                      const IntVect& les_polys,
                                      DoubleTab& val) const
{
  entier som;
  double xs,ys,zs;
   
  const Zone_dis_base& zone_dis = zone_dis_base();
  const Zone& zone_geom = zone_dis.zone();
  const DoubleTab& coord = zone_geom.domaine().coord_sommets();
  const IntTab& sommet_poly = zone_geom.les_elems();
  if (val.nb_dim() == 1) {
    assert((val.dimension(0) == les_polys.size())||(val.dimension_tot(0) == les_polys.size()));
    assert(nb_compo_ == 1);
  }
  else if (val.nb_dim() == 2) {
    assert(val.dimension_tot(0) == les_polys.size());
    //assert((val.dimension(0) == les_polys.size())||(val.dimension_tot(0) == les_polys.size()));
    assert(val.dimension(1) == nb_compo_);
  }
  else {
    Cerr << "Error TRUST in Champ_P1NC::valeur_aux()\n";
    Cerr << "The DoubleTab val has more than 2 entries\n";
    exit();
  }
  entier le_poly;
   
  if (nb_compo_ == 1) 
    {
      const DoubleVect& ch = valeurs();
      
      for(entier rang_poly=0; rang_poly<les_polys.size(); rang_poly++)
        {
          le_poly=les_polys(rang_poly);
          if (le_poly == -1)
            if (val.nb_dim() == 1)
              val(rang_poly) = 0;
            else
              val(rang_poly,0) = 0;
          else 
            {
              // Calcul d'apres les fonctions de forme sur le triangle
              if (val.nb_dim() == 1)
                val(rang_poly) = 0;
              else
                val(rang_poly,0) = 0;
              if (dimension == 2) {
                xs = positions(rang_poly,0);
                ys = positions(rang_poly,1);
                if (val.nb_dim() == 1) {
                  for (entier i=0; i< 3; i++) {
                    som = sommet_poly(le_poly,i);
                    val(rang_poly) += ch(som)
                      * coord_barycentrique_P1(sommet_poly, coord, xs, ys, 
                                               le_poly, i);
                  }
                }
                else {
                  for (entier i=0; i< 3; i++) {
                    som = sommet_poly(le_poly,i);
                    val(rang_poly,0) += ch(som)
                      * coord_barycentrique_P1(sommet_poly, coord, xs, ys, 
                                               le_poly, i);        
                  }        
                }
              }
              else if (dimension == 3) {
                xs = positions(rang_poly,0);
                ys = positions(rang_poly,1);
                zs = positions(rang_poly,2);
                if (val.nb_dim() == 1) {
                  for (entier i=0; i< 4; i++) {
                    som = sommet_poly(le_poly,i);
                    val(rang_poly) += ch(som)
                      * coord_barycentrique_P1(sommet_poly, coord, xs, ys, zs, 
                                               le_poly, i);
                  }
                }                                        
                else {
                  for (entier i=0; i< 4; i++) {
                    som = sommet_poly(le_poly,i);
                    val(rang_poly,0) += ch(som)
                      * coord_barycentrique_P1(sommet_poly, coord, xs, ys, zs, 
                                               le_poly, i);
                  }                                                        
                }
              }
            }
        }
    }
  else // nb_compo_ > 1
    {
      const DoubleTab& ch = valeurs();
      
      for(entier rang_poly=0; rang_poly<les_polys.size(); rang_poly++)
        {
          le_poly=les_polys(rang_poly);
          if (le_poly == -1)
            for(entier ncomp=0; ncomp<nb_compo_; ncomp++)
              val(rang_poly, ncomp) = 0;
          else 
            {
              for(entier ncomp=0; ncomp<nb_compo_; ncomp++) {
                val(rang_poly, ncomp) = 0;
                if (dimension == 2) {
                  xs = positions(rang_poly,0);
                  ys = positions(rang_poly,1);
                  for (entier i=0; i< 3; i++) {
                    som = sommet_poly(le_poly,i);
                    val(rang_poly, ncomp) += ch(som, ncomp)
                      * coord_barycentrique_P1(sommet_poly, coord, xs, ys, 
                                               le_poly, i);
                  }
                }
                else if (dimension == 3) {
                  xs = positions(rang_poly,0);
                  ys = positions(rang_poly,1);
                  zs = positions(rang_poly,2);
                  for (entier i=0; i< 4; i++) {
                    som = sommet_poly(le_poly,i);
                    val(rang_poly, ncomp) += ch(som, ncomp)
                      * coord_barycentrique_P1(sommet_poly, coord, xs, ys, zs,
                                               le_poly, i);
                  }
                }
              }
            }
        }         
    }   
  return val;
}


// Description: 
//    Renvoie les valeurs d'une composante du champ aux points specifies
//    par leurs coordonnees, en indiquant que les points de
//    calculs sont situes dans les elements indiques.
// Precondition: il y autant de valeurs que d'elements specifies
// Parametre: DoubleTab& 
//    Signification: le tableau des coordonnees des points de calcul
//    Valeurs par defaut: 
//    Contraintes: reference constante
//    Acces: entree
// Parametre: IntVect& les_polys
//    Signification: le tableau des elements dans lesquels sont
//                   situes les points de calcul
//    Valeurs par defaut: 
//    Contraintes: reference constante
//    Acces: entree
// Parametre: DoubleVect& val
//    Signification: le tableau des valeurs de la composante du champ 
//                   aux points specifies
//    Valeurs par defaut: 
//    Contraintes: 
//    Acces: entree/sortie
// Parametre: entier ncomp
//    Signification: l'index de la composante du champ a calculer
//    Valeurs par defaut: 
//    Contraintes: 
//    Acces: 
// Retour: DoubleVect& 
//    Signification: le tableau des valeurs de la composante du champ 
//                   aux points specifies
//    Contraintes: 
// Exception: 
// Effets de bord: 
// Postcondition: la methode ne modifie pas l'objet 
DoubleVect& Champ_P1::valeur_aux_elems_compo(const DoubleTab& positions, 
                                             const IntVect& les_polys,
                                             DoubleVect& val,
                                             entier ncomp) const
{
  entier som;
  double xs,ys,zs;
   
  const Zone_dis_base& zone_dis = zone_dis_base();
  const Zone& zone_geom = zone_dis.zone();
  const DoubleTab& coord = zone_geom.domaine().coord_sommets();
  const IntTab& sommet_poly = zone_geom.les_elems();
  assert(val.size() == les_polys.size());
  entier le_poly;
   
  const DoubleTab& ch = valeurs();
   
  for(entier rang_poly=0; rang_poly<les_polys.size(); rang_poly++)
    {
      le_poly=les_polys(rang_poly);
      if (le_poly == -1)
        val(rang_poly) = 0;
      else 
        {
          val(rang_poly) = 0;
          if (dimension == 2) {
            xs = positions(rang_poly,0);
            ys = positions(rang_poly,1);
            for (entier i=0; i< 3; i++) {
              som = sommet_poly(le_poly,i);
              val(rang_poly) += ch(som, ncomp)
                * coord_barycentrique_P1(sommet_poly, coord, xs, ys, le_poly, i);
            }
          }
          else if (dimension == 3) {
            xs = positions(rang_poly,0);
            ys = positions(rang_poly,1);
            zs = positions(rang_poly,2);
            for (entier i=0; i< 4; i++) {
              som = sommet_poly(le_poly,i);
              val(rang_poly) += ch(som, ncomp)
                * coord_barycentrique_P1(sommet_poly, coord, xs, ys, zs, 
                                         le_poly, i);
            }
          }
        }
    }
  return val;
}

const Zone_dis_base& Champ_P1::zone_dis_base() const
{
  return Champ_base::zone_dis_base();
}

entier Champ_P1::fixer_nb_valeurs_nodales(entier nb_noeuds)
{
  assert(nb_noeuds == domaine().nb_som());
  const MD_Vector & md = domaine().md_vector_sommets();
  creer_tableau_distribue(md);  
  return 1;
}
