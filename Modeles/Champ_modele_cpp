//////////////////////////////////////////////////////////////////////////////
//
// File:	NOM_DU_FICHIER.cpp
// Directory:	$TRUST_ROOT/NOM_DU_MODULE
//
//////////////////////////////////////////////////////////////////////////////

#include <NOM_DU_FICHIER.h>
implemente_instanciable_sans_constructeur(NOM_DE_LA_CLASSE,
                                          "NOM_DE_LA_CLASSE",
					  Champ_Don_base);

Sortie& NOM_DE_LA_CLASSE::printOn(Sortie& os) const
{
  return os;
}

Entree& NOM_DE_LA_CLASSE::readOn(Entree& is) 
{
  //
  // LIRE ICI LES PARAMETRES EVENTUELS
  // EXEMPLE :
  // Motcles les_mots(2);
  // Motcle mot_lu;
  // {
  //    les_mots[0]="a";
  //    les_mots[1]="b";
  // }
  // Motcle acc_ouverte("{");
  // Motcle acc_fermee("}");
  // is >> mot_lu;
  // if(mot_lu != acc_ouverte)
  // {
  //    Cerr << "On attendait { a la place de " << mot_lu
  //         << " lors de la lecture d'un NOM_DE_LA_CLASSE " << finl;
  // }
  // is >> mot_lu;
  // while(mot_lu != acc_fermee)
  // {
  //    int rang=les_mots.search(mot_lu);
  //    switch(rang)
  //    {
  //       case 0 :
  //           is >> a;
  //           break;
  //       case 1  :
  //           is >> b;
  //           break;
  //       default :
  //       {
  //           Cerr << mot_lu << " n'est pas un mot compris par NOM_DE_LA_CLASSE" << finl;
  //           Cerr << "Les mots compris sont : " << les_mots << finl;
  //           exit(-1);
  //       }
  //    }
  //    is >> mot_lu;
  // }
  //
  return is;
}

// Description:
//
NOM_DE_LA_CLASSE::NOM_DE_LA_CLASSE()
{
  dimensionner(1,NOMBRE_DE_COMPOSANTES);
}

// Description:
//
Champ_base& NOM_DE_LA_CLASSE::affecter(const Champ_base& ch)
{
  //
  // Cette methode ne doit pas etre appelee!
  //
  assert(0);
  Cerr << "On ne doit pas appeler NOM_DE_LA_CLASSE::affecter" << finl;
  exit(-1);
  return *this;
}

// Description:
// Renvoie la valeur en un point.
DoubleVect& NOM_DE_LA_CLASSE::valeur_a(const DoubleVect& positions, 
				       DoubleVect& valeurs) const
{
  valeurs.resize(nb_compo_);
  switch(dimension)
    {
    case(1):
      {
	assert(nb_compo_==1);
	valeurs(0)= fx(positions(0));
	break;
      }
    case(2):
      {
	assert(nb_compo_<=2);
	valeurs(0)= fx(positions(0), positions(1));
	if(nb_compo_==2)
	  valeurs(1)= fy(positions(0), positions(1));
	break;
      }
    case(3):
      {
	assert(nb_compo_<=3);
	valeurs(0)= fx(positions(0), positions(1), positions(2));
	if(nb_compo_>=2)
	  valeurs(1)= fy(positions(0), positions(1), positions(2));
	if(nb_compo_>=3)
	  valeurs(2)= fz(positions(0), positions(1), positions(2));
	break;
      }
    }
  return valeurs;
}

// Description:
//
DoubleVect& NOM_DE_LA_CLASSE::valeur_a_elem(const DoubleVect& positions, 
					    DoubleVect& valeurs, 
					    int poly) const
{
  return valeur_a(positions, valeurs);
}

// Description:
//
double NOM_DE_LA_CLASSE::valeur_a_elem_compo(const DoubleVect& positions, 
					     int ,int ncomp) const
{
  double val;
  switch(dimension)
    {
    case(1):
      {
	switch(ncomp)
	  {
	  case(1):
	    val=fx(positions(0));
	    break;
	  }
      }
      break;
    case(2):
      {
	switch(ncomp)
	  {
	  case(1):
	    val=fx(positions(0),positions(1));
	    break;
	  case(2):
	    val=fy(positions(0),positions(1));
	    break;
	  }
      }
      break;
    case(3):
      {
	switch(ncomp)
	  {
	  case(1):
	    val=fx(positions(0),positions(1),positions(2));
	    break;
	  case(2):
	    val=fy(positions(0),positions(1),positions(2));
	    break;
	  case(3):
	    val=fz(positions(0),positions(1),positions(2));
	    break;
	  }
      }
      break;
    }
  return val;
}

// Description:
//
DoubleTab& NOM_DE_LA_CLASSE::valeur_aux(const DoubleTab& positions, 
					DoubleTab& valeurs) const
{
  int nb_pos=positions.dimension(0);
  valeurs.resize(nb_pos, NOMBRE_DE_COMPOSANTES);
  int i;
  switch(dimension)
    {
    case(1):
      {
	assert(nb_compo_==1);
	for(i=0; i<valeurs.dimension(0); i++)
	  {
	    valeurs(i,0)= fx(positions(i,0));
	  }
	break;
      }
    case(2):
      {
	assert(nb_compo_<=2);
	for(i=0; i<valeurs.dimension(0); i++)
	  {
	    valeurs(i,0)= fx(positions(i,0), positions(i,1));
	    if(nb_compo_==2)
	      valeurs(i,1)= fy(positions(i,0), positions(i,1));
	  }
	break;
      }
    case(3):
      {
	assert(nb_compo_<=3);
	for(i=0; i<valeurs.dimension(0); i++)
	  {
	    valeurs(i,0)= fx(positions(i,0), positions(i,1), positions(i,2));
	    if(nb_compo_>=2)
	      valeurs(i,1)= fy(positions(i,0), positions(i,1), positions(i,2));
	    if(nb_compo_>=3)
	      valeurs(i,2)= fz(positions(i,0), positions(i,1), positions(i,2));
	  }
	break;
      }
    }
  return valeurs;
}

// Description:
//
DoubleVect& NOM_DE_LA_CLASSE::valeur_aux_compo(const DoubleTab& positions, 
					       DoubleVect& valeurs, int ncomp) const
{
  int nb_pos=positions.dimension(0);
  valeurs.resize(nb_pos);
  assert(ncomp<NOMBRE_DE_COMPOSANTES);
  int i;
  switch(dimension)
    {
    case 1:
      {
	for(i=0; i<nb_pos; i++)
	  valeurs(i)= fx(positions(i,0));
	break;
      }
    case 2:
      {
	if(ncomp==0)
	  for(i=0; i<nb_pos; i++)
	    valeurs(i)= fx(positions(i,0), positions(i,1));
	else
	  for(i=0; i<nb_pos; i++)
	    valeurs(i)= fy(positions(i,0), positions(i,1));
	break;
      }
    case 3:
      {
	if(ncomp==0)
	  for(i=0; i<nb_pos; i++)
	    valeurs(i)= fx(positions(i,0), positions(i,1), positions(i,2));
	else if(ncomp==1)
	  for(i=0; i<nb_pos; i++)
	    valeurs(i)= fy(positions(i,0), positions(i,1), positions(i,2));
	else
	  for(i=0; i<nb_pos; i++)
	    valeurs(i)= fz(positions(i,0), positions(i,1), positions(i,2));
	break;
      }
    }
  return valeurs;
}

// Description:
//
DoubleTab& NOM_DE_LA_CLASSE::valeur_aux_elems(const DoubleTab& positions,
					      const IntVect& ,
					      DoubleTab& valeurs) const
{
  return valeur_aux(positions, valeurs);
}

// Description:
//
DoubleVect& NOM_DE_LA_CLASSE::valeur_aux_elems_compo(const DoubleTab& positions,
						     const IntVect& ,
						     DoubleVect& valeurs, 
						     int ncomp) const
{
  return valeur_aux_compo(positions, valeurs, ncomp);
}
