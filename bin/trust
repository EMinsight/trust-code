#!/bin/bash
# Lancement de TRUST par clavier avec comme argument 
# le nom du jeu de donnees et le nombre de processeurs
# Possibilite de fixer des noeuds en specifiant un fichier machinefile
# Variables d'environnements qui influencent le script: 
# exec (fixe au chemin global de l'executable a utiliser)
# bigmem (fixee a 1 elle permet de lancer en batch sur des noeuds a 4Go de tantale)
# node (fixee a 1 elle permet d'utiliser tous les processeurs d'un noeud)
# prod (fixee a 1 elle permet d'utiliser la queue de production)
# Chargement d'un environnement eventuel contenu dans ld_env.sh
if [ -f ld_env.sh ]
then
   . ./ld_env.sh
fi

qsub_interactif()
{   
   # Provisoire qsub ne marche pas donc on lance direct:
   id=`cat $sub_file | qsub | $TRUST_Awk -F . '{print $1}'`
   # Attente de la fin du job
   while [ "`qstat -a | grep $id`" != "" ]
   do
      sleep 3
   done
}
bsub_interactif()
{
   # Provisoire bsub -I desactive sur argent donc on lance direct:
   id=`cat $sub_file | bsub | $TRUST_Awk '{gsub("<","",$2);gsub(">","",$2);print $2}'`
   # Attente de la fin du job
   while [ "`qstat -a | grep $id`" != "" ]
   do
      sleep 3
   done
}
sbatch_interactif()
{
   # Submit the job and returns the id:
   err=1
   while [ "$err" = 1 ]
   do
      id=`sbatch $sub_file 2>&1`
      err=$?
      # Wait if several jobs launched
      if [ $err = 1 ]
      then
         if [ "`echo $id | grep 'Job violates accounting'`" != "" ]
         then
	    echo "Waiting, cause several jobs submitted:"
	    squeue -u $me -p $queue
	    sleep 60
	 else
	    # Unknown error
            echo $id && exit -1 
	 fi
      fi     
   done
   id=`echo $id | $TRUST_Awk '/Submitted batch/ {print $NF}'`
   echo "Job $id submitted."
   echo "Waiting the end of the job $id..."
   while [ "`squeue -h -j $id 2>/dev/null`" != "" ]
   do
      sleep 3
   done
}
# Sur les dernieres machines du CCRT on utilise desormais un wrapper ccc_msub (au lieu de qsub, bsub,...) 
# Il faut aussi utiliser ccc_mdel au lieu de qdel et ccc_mstat au lieu de qstat...
ccc_msub_interactif()
{
   # Submit the job and returns the id:
   err=1
   while [ "$err" = 1 ]
   do
      id=`ccc_msub $sub_file 2>&1`
      err=$?
      # Wait if several jobs launched
      if [ $err = 1 ]
      then
         if [ "`echo $id | grep 'Job violates accounting'`" != "" ]
         then
	    echo "Waiting, cause several jobs submitted:"
	    #qstat -u $me $queue
	    #ccc_mpstat -u $me $queue
	    squeue -u $me -p $queue
	    sleep 60
	 else
	    # Unknown error
            echo $id && exit -1 
	 fi
      fi     
   done
   id=`echo $id | $TRUST_Awk '/Session/ {print $4}'`
   echo "Job $id submitted."
   echo "Waiting the end of the job $id..."
   #while [ "`qstat -u $me | grep $id`" != "" ]
   #while [ "`ccc_mpstat -u $me | grep $id`" != "" ]
   while [ "`squeue -h -j $id 2>/dev/null`" != "" ]
   do
      sleep 3
   done
}

help()
{
   echo "Usage: `basename $0` [option] datafile [nb_cpus] [1>file.out] [2>file.err]"
   echo "Where option may be:"
   echo "-help|-h                      : List options."
   echo "-baltik [baltik_name]         : Instanciate an empty Baltik project."
   echo "-index                        : Access to the TRUST ressource index."
   echo "-doc                          : Access to the TRUST manual (Generic Guide)."
   echo "-config nedit|vim|emacs|gedit : Configure nedit or vim or emacs or gedit with TRUST keywords."
   echo "-edit                         : Edit datafile."
   echo "-xedit                        : Edit datafile with xdata."
   echo "-xcheck                       : Check the datafile's keywords with xdata."
   echo "-partition                    : Partition the mesh to prepare a parallel calculation (Creation of the .Zones files)."
   echo "-mesh                         : Visualize the mesh(es) contained in the data file."
#   echo "-monitor                : Run and monitor the progress of the TRUST calculation."
   echo "-probes                       : Monitor the TRUST calculation only."
   echo "-evol                         : Monitor the TRUST calculation (new IHM)."
   echo "-wiz                          : Create a TRUST datafile from a MED file (new IHM)."
   echo "-prm                          : Write a prm file."
   echo "-clean                        : Clean the current directory from all the generated files by TRUST."
   echo "-search keywords              : Know the list of test cases from the data bases which contain keywords."
   echo "-copy                         : Copy the test case datafile from the TRUST database under the present directory."
   echo "-check all|testcase|list      : Check the non regression of all the test cases or a single test case or a list of tests cases specified in a file."
   echo "-check function|class|class::method : Check the non regression of a list of tests cases covering a function, a class or a class method."
   echo "-gdb                          : Run under gdb debugger."
   echo "-valgrind                     : Run under valgrind."
   echo "-valgrind_strict              : Run under valgrind with no suppressions."
   echo "-create_sub_file              : Create a submission file only."
   echo "-prod                         : Create a submission file and submit the job on the main production class with exclusive resource."
   echo "-bigmem                       : Create a submission file and submit the job on the big memory production class."
   echo "-queue queue                  : Create a submission file with the specified queue and submit the job."
   echo "-c ncpus                      : Use ncpus CPUs allocated per task for a parallel calculation."
#   [ "$PETSC_HAVE_CUDA" = 1 ] && echo "-gpu                    : Create a submission file and submit the job on production class with GPU cards."
#   [ -d /ccc ] && echo "-ipm                    : Use ipm to report MPI statistics."
   echo "datafile -help_trust          : Print options of TRUST_EXECUTABLE [CASE[.data]] [options]."

   exit 0
}
binary=$exec
ici=`pwd`   
me=`whoami`
edit=""
xedit=""
xcheck=""
partition=""
mesh=""
monitor=""
probes=""
prm=""
copy=""
gdb=""
taches=""
cpus_per_task=""
queue_choisie=""
[ "$prod" = "" ] && prod=0
[ "$bigmem" = "" ] && bigmem=0
gpu=0
node=0
[ "$USE_MPIRUN" = "" ] && USE_MPIRUN=0

####################
# Loop for options #
####################
supported_option=1
while [ "$supported_option" = 1 ]
do
   if [ "$1" = "" ] || [ "$1" = -help ] || [ "$1" = -h ]
   then
      help
      exit 0
   elif [ "$1" = "-config" ]
   then
      shift
      if [ "$1" = nedit ]
      then
         # Configure nedit
	 Language_mode_TRUST.sh #-no_verbose
	 exit 0
      elif [ "$1" = vim ]
      then
         # Configure vim
	 configure_vim.sh && exit 0
      elif [ "$1" = emacs ]
      then
         # Configure emacs
	 configure_emacs.sh && exit 0
      elif [ "$1" = gedit ]
      then
         # Configure gedit
	 configure_gedit.sh && exit 0
      else
         help
      fi
   elif [ "$1" = "-doc" ]
   then
      if [ "$project_directory" != "" ]
      then
          
          doc=$project_directory/share/doc_auto/TRUST_Generic_Guide.pdf
          if [ ! -f $doc ] 
            then
             doc=$project_directory/share/doc/TRUST_Generic_Guide.pdf
	     [ ! -f $doc ] && doc=$TRUST_ROOT/doc/TRUST/TRUST_Generic_Guide.pdf
            else
		echo "Using doc generated"
           fi
      else
         doc=$TRUST_ROOT/doc/TRUST/TRUST_Generic_Guide.pdf
      fi
      if [ -f $doc ]
      then
	 for app in evince xpdf kpdf okular
	 do
            $app $doc 1>/dev/null 2>&1 && exit 0
	 done
	 echo "No PDF reader found!"
	 exit -1
      else
	 echo "$doc not found!" 
	 exit -1
      fi
   elif [ "$1" = "-baltik" ]
   then
      [ -f bin/trust ] && echo "Can't be run at $TRUST_ROOT" && exit -1 
      shift
      if [ "$1" != "" ] 
      then
         baltik_name=$1
         mkdir -p $baltik_name
         cd $baltik_name
      fi
      echo "Creating an empty Baltik project under `pwd` ..."
      echo "Copying a template from \$TRUST_ROOT/bin/baltik/templates/basic ..."
      cp -r $TRUST_ROOT/bin/baltik/templates/basic/* .
      echo "Changing the project configuration file project.cfg ..."
      sed -i "1,$ s?TRUST?`whoami 2>/dev/null`?g" project.cfg
      project=`pwd` && project=`basename $project`
      sed -i "1,$ s?basic?$project?g" project.cfg
      echo "Suppressing Hello World examples from the project ..."
      rm -r -f src/Hello.* tests/Reference/New/Hello tests/Reference/New/new tests/Reference/Validation/Hello_world_jdd1 share/Validation/Rapports_automatiques/Hello_world
      echo "Running baltik_build_configure..."
      baltik_build_configure
      echo "Read the README.BALTIK file to know more about Baltik projects." 
      #./configure && make check_optim
      exit 0
   elif [ "$1" = "-index" ]
   then
      ($TRUST_WEBBROWSER $TRUST_ROOT/index.html &) && exit 0  
   elif [ "$1" = "-exec" ] ||  [ "$1" = "-exe" ]
   then
      shift
      binary=$1
   elif [ "$1" = "-copy" ]
   then
      copy=1
   elif [ "$1" = "-edit" ]
   then
      edit=1
   elif [ "$1" = "-xedit" ]
   then
      xedit=1
   elif [ "$1" = "-xcheck" ]
   then
      xcheck=1
   elif [ "$1" = "-partition" ]
   then
      partition=1
   elif [ "$1" = "-mesh" ]
   then
      mesh=1
   elif [ "$1" = "-c" ]
   then
      shift && cpus_per_task=$1
   elif [ "$1" = "-monitor" ]
   then
      monitor=1
   elif [ "$1" = "-probes" ]
   then
      probes=1
   elif [ "$1" = "-evol" ]
   then
      probes=2
   elif [ "$1" = "-wiz" ]
   then
      bash  $TRUST_ROOT/exec/TRUST_WIZARD/TRUST_Wizard.sh
      exit $?
   elif [ "$1" = "-create_sub_file" ]
   then
      create_sub_file=1 && prod=1 #&& node=1
   elif [ "$1" = "-queue" ]
   then
      shift && queue_choisie=$1
   elif [ "$1" = "-prod" ]
   then
      prod=1 && node=1
   elif [ "$1" = "-gpu" ]
   then
      gpu=1
   elif [ "$1" = "-bigmem" ]
   then
      bigmem=1
   elif [ "$1" = "-ipm" ]
   then
      ipm=1
   elif [ "$1" = "-valgrind" ]
   then 
      VALGRIND=1
   elif [ "$1" = "-valgrind_strict" ]
   then
      VALGRIND_STRICT=1
   elif [ "$1" = "-gdb" ]
   then
      gdb=gdb.sh && mpirun_options="-gdb"
   elif [ "$1" = "-prm" ]
   then
      prm=1 
   elif [ "$1" = "-search" ]
   then
      shift
      option=""
      while [ "$1" != "" ]
      do
	 option=$option" "$1
         shift
      done
      cherche.ksh $option
      exit $?
   elif [ "$1" = "-check" ]
   then
      shift
      if [ "$1" = "" ]
      then
	 help
      elif [ "$1" = all ]
      then
	 # All test cases
	 option=0 
      # elif [ "`ls $TRUST_TESTS/*/$1/$1.lml.gz 2>/dev/null`" != "" ]
      elif [ "`find $TRUST_TESTS/ -follow -name $1.lml.gz -print 2>/dev/null | sort`" != "" ]
      then
	 # Single test case
	 option=$1   
      elif [ -f $1 ]
      then
	 # List of test cases in a file
	 option=$1   
      else
	 # Test cases covering a method::class
	 Qui $1 || exit -1
	 option=liste_cas
      fi
      echo $option | lance_test -no_timeout $binary
      exit $?
   elif [ "$1" = "-clean" ]
   then
      for ext in lata sons son out lml dt_ev TU log stop err xyz sauv dump face out_err plan progress
      do 
	 echo "rm *.$ext files."
	 rm -f *.$ext
      done
      # echo "rm *.lata.* core.* err.* out.*"
      # rm -f *.lata.* core.* err.* out.*
	  # A priori c est un peu fort : err.* out.* ne sont pas crees au run. 
      echo "rm *.lata.* core.* convert_jdd"
      rm -f core.* convert_jdd
      find . -maxdepth 1 -name '*.lata.*' -exec  rm  {} \;
      echo "rm *_Channel_Flow_Rate_* *_Pressure_Gradient_*"
      rm -f *_Channel_Flow_Rate_* *_Pressure_Gradient_*
      echo "rm Moyennes_spatiales_* reynolds_tau.dat tauw.dat u_tau.dat"
      rm -f Moyennes_spatiales_* reynolds_tau.dat tauw.dat u_tau.dat
      echo "rm evol_glob"
      rm -f evol_glob
      echo "rm iter.dat sauvegarde_tble_* tble_mesh.dat"
      rm -f iter.dat sauvegarde_tble_* tble_mesh.dat
      exit 0
   else
      # Unknown option
      supported_option=0
   fi 
   # Option is known, jump to next
   [ "$supported_option" = 1 ] && shift
done
# deplace pas besoin d exec pour clean help ....
[ "$exec" = "" ] && echo "Error: the variable \$exec containing TRUST binary path is undefined." && exit -1
[ ! -f $exec ] && echo "Error: the binary pointed by the variable \$exec=$exec does NOT exist." && exit -1  

############
# Filename #
############
NOM=`basename $ici` && [ ${#1} != 0 ] && NOM=$1 && NOM=${NOM%.data} && shift
[ "${NOM:0:1}" = "-" ] && echo "Error: option not included" && help && exit 0

###############
# CPU numbers #
###############
# si $1 non vide et pas de tiret au debut
#export NB_PROCS=1 && [ ${#1} != 0 ] && [ ${1#-} = $1 ] && NB_PROCS=$1 && USE_MPIRUN=1 && shift
export NB_PROCS=1 
[ $1 -eq 0 ] 2>/dev/null
code_retour=$?
# verifie que $1 est une valeur numerique
if [ $code_retour -eq 0 -o $code_retour -eq 1 ]
then 
  [ ${#1} != 0 ] && [ ${1#-} = $1 ] && export NB_PROCS=$1 && USE_MPIRUN=1 && shift
fi
# verifie si le code est compile en parallele ou non
[ "$TRUST_DISABLE_MPI" = 1 ] && [ "$USE_MPIRUN" = 1 ] && export USE_MPIRUN=0

#################
# PETSc options #
#################
[ "$PETSC_OPTIONS" = "" ] && PETSC_OPTIONS=$*
if [ "`echo $PETSC_OPTIONS | grep -i cusp`" != "" ]
then
   gpu=1 # Activate also GPU option if some gpu option is passed through the command line option:
fi

###########################################
# Lancement en interactif avec monitoring #
###########################################
if [ "$monitor" = 1 ]
then
   Run_sonde $binary $NOM
   exit $?
fi

########################
# Monitoring seulement #
########################
if [ "$probes" = 1 ]
then
   Run_sonde $NOM
   exit $?
fi
if [ "$probes" = 2 ]
then 
   DIR=`dirname $NOM`
   DIR=`(cd $DIR;pwd)`
   cd $DIR
   dt_ev=$DIR/`basename $NOM`.dt_ev
   #[ ! -f $dt_ev ] && echo "# temps          dt              facsec          residu=max|Ri| dt_stab i1 I2" >$dt_ev && echo 0 1 1 1 1  1 1>> dt_ev
   let i=1
   while [ $i -le 0 ]
   do
      let i=i+1
     # break
      [ -f $dt_ev ] && break
      echo "waiting for $dt_ev"
     sleep 0.1
   done
   #[ ! -f $dt_ev ] && exit 1
   bash  $TRUST_ROOT/exec/TRUST_PLOT2D/Plot2d.sh $DIR/`basename $NOM`.data "residu=max|Ri|"
   err=$?
   if [ $err != 0 ]
   then
      echo " "
      echo "If Matplotlib error, so you could try to recompil PySide with the following command:"
      echo "(cd "$TRUST_ROOT"/Outils/Python_modules/;env FORCE_BUILD=1 make clean PySide)" 
      echo "Warning: This may cause a different behavior from the Python environment." 
   fi
   exit $err
fi

#############
# Edit data #
#############
if [ "$edit" = 1 ]
then
   editor=$TRUST_EDITOR
   [ "$editor" = "" ] && editor="xemacs"
   $editor $NOM".data" &
   exit $?
fi

########################
# Edit data with xdata #
########################
if [ "$xedit" = 1 ]
then
   $TRUST_ROOT/bin/EditData $NOM".data"
   exit $?
fi

##########################
# Verify data with xdata #
##########################
if [ "$xcheck" = 1 ]
then
   $TRUST_ROOT/bin/VerifData $NOM".data"
   exit $?
fi

##################
# Partition mesh #
##################
if [ "$partition" = 1 ]
then
   if [ $NB_PROCS -eq 1 ]
   then
      make_PAR.data $NOM
   else
      make_PAR.data $NOM $NB_PROCS
   fi
   exit $?
fi

#################
# Visu maillage #
#################
if [ "$mesh" = 1 ]
then
   Check_maillage.ksh $NOM
   exit $?
fi

#####################
# Generate pdf file #
#####################
if [ "$prm" = 1 ]
then
   create_basic_prm_from_lata.sh $NOM
   exit $?
fi

################
# Copy a study #
################
if [ "$copy" = 1 ]
then
   echo "Try to extract $NOM test case from $TRUST_TESTS database..."
   copie_cas_test $NOM
   err=$?
   if [ "$err" = 0 ]
   then
      echo "Directory `pwd`/$NOM created with files inside:" && ls $NOM
   else
      echo "ERROR: Directory `pwd`/$NOM NOT created !!!"
   fi
   exit $err
fi

############
# VALGRIND #
############
if [ "$VALGRIND" = "1" ] || [ "$VALGRIND_STRICT" = "1" ] || [ "$VALGRIND_GDB" = "1" ]
then
    val=`which valgrind`    
    suppressions=""
    if [ "$VALGRIND_STRICT" != "1" ]
    then
        suppressions="--gen-suppressions=all"
	if [ "`$Mpirun --version 2>&1 | grep 1.2.9`" != "" ]
	then
	   # Ajout de suppressions supplementaires pour OpenMPI 1.2.9
	   cat $TRUST_ROOT/Outils/valgrind/suppressions_openmpi_129 $TRUST_ROOT/Outils/valgrind/suppressions > $TRUST_TMP/suppressions
	   suppressions=$suppressions" --suppressions=$TRUST_TMP/suppressions"
	else
	   suppressions=$suppressions" --suppressions=$TRUST_ROOT/Outils/valgrind/suppressions"
	fi
    fi
    if [ "$gdb" != "" ] || [ "$VALGRIND_GDB" = "1" ]
    then
       MonoDir=$TRUST_ROOT/`ls -rt $TRUST_ROOT | grep MonoDir | tail -1`
       XTERM="/usr/bin/xterm -e"
       ATTACH="--extra-debuginfo-path=$MonoDir/src --db-attach=yes --db-command=\'/usr/bin/gdb --readnow --directory $MonoDir/src --directory $MonoDir/include -nw %f %p\'"
       gdb=""
       log_file=""
    fi
    if [ "$VALGRIND_LOG_FILE" = 1 ]
    then
       # Call from testval:
       log_file="--log-file=tmp_log%p" 
    else
       # Too slow in testval:
       more_info_but_slower="--track-origins=yes"
    fi
    #  more_info_but_slower=""      # --track-origins=yes"
    # GF sinon on a des erreurs au demarrage de mpi
    [ $NB_PROCS -ge 2 ] && log_file="--log-file=tmp_log%p" 
    #  log_file="--log-file=tmp_log%p" 
    # Still reachable only checked for OpenMPI 1.2.9: 
    if [ "`$Mpirun --version | grep 1.2.9`" != "" ]
    then
       reachable=yes
    else
       reachable=yes
       # Cause MPI_irecv, a table is allocated but not freed, see 4.8.6 in https://wiki.uiowa.edu/download/attachments/109785161/Valgrind-Quick-Start.pdf?version=1&modificationDate=1385057441990&api=v2
    fi
    exec="$XTERM $val --error-exitcode=1 --leak-check=full --show-leak-kinds=all --errors-for-leak-kinds=all   --show-reachable=$reachable --num-callers=15 $log_file $more_info_but_slower $suppressions $ATTACH $binary"
fi

###############################################
# Utilisation de Petsc dans le jeu de donnees ?
# et eventuellement dans le JDD du baltik MC2 ?
###############################################
USE_PETSC=0
if [ -f $NOM.data ]
then 
   # To avoid dos problems:
   dos2unix_ $NOM.data
   USE_PETSC=`sed "s/\t/ /g" $NOM.data | $TRUST_Awk 'BEGIN {IGNORECASE=1;use_petsc=0} \
                            // {n=split($0,a,"#")-1;if (n>0) dieses+=n} \
                            /^fin/ && (dieses%2==0) && (NF==1) {exit} \
                            / petsc / || / petsc_gpu / || / optimal / || / resoudremultiassemblage / || / resoudre / {use_petsc=1;exit}
	                    END {print use_petsc}'`
   USE_PETSC_GPU=`sed "s/\t/ /g" $NOM.data | $TRUST_Awk 'BEGIN {IGNORECASE=1;use_petsc_gpu=0} \
                            // {n=split($0,a,"#")-1;if (n>0) dieses+=n} \
                            /^fin/ && (dieses%2==0) && (NF==1) {exit} \
                            / petsc_gpu / {use_petsc_gpu=1;exit}
	                    END {print use_petsc_gpu}'`
fi
if [ $PETSC_HAVE_CUDA = 1 ] && [ $USE_PETSC = 1 ]
then
   gpu=1
fi

######################
# Selon les machines #
######################
soumission=999
sub="" 
queue=""
qos=""
cpu=""
ram=""
noeuds=""
export espacedir
export project
export prod
export bigmem
export node
export gpu
# See HOST_???.sh file called in TRUST.env
if [ "$TRUST_WITHOUT_HOST" = 0 ]
then
   source $TRUST_ROOT/env/HOST_$HOST_BUILD.sh
else
   source $TRUST_ROOT/env/HOST_default.sh
fi
define_soumission_batch

######################################
# Check the datafile with VerifData on 
# clusters with job scheduling if exec
# is a TRUST binary
######################################
#if [ $soumission != 999 ] && [ ${binary#TRUST} != $binary ] && [ "`VerifData 1>/dev/null 2>&1;echo $?`" = 0 ]
shortbin=${binary##*/}
if [ $soumission != 999 ] && [ ${shortbin#TRUST} != $shortbin ] && [ "`VerifData 1>/dev/null 2>&1;echo $?`" = 0 ] && [ $NB_PROCS -gt 1 ]
then
   echo $ECHO_OPTS "Checking the syntax of the $NOM.data file before submitting the job...\c"
   VerifData $NOM.data 1>/dev/null 2>&1
   if [ $? != 0 ]
   then
       echo KO
       echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
       echo "Check your data file. Syntax error detected:"
       echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
       VerifData $NOM.data
       echo "Error: Check your $NOM.data file."
       #exit -1
   else
       echo OK
   fi
fi

# En sequentiel, si l'utilisateur n'a pas force l'utilisation de MPI_RUN et 
# si le Kernel est compile avec MPI_INIT_NEEDS_MPIRUN, alors on utilise mpi_run sauf si
# on est sur de ne pas utiliser un solveur PETSC ou OPTIMAL dans le jeu de donnees
if  [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 0 ]
then
   petsc_for_kernel=$PETSC_ROOT/$TRUST_ARCH/include/petsc_for_kernel.h
   if [ ! -f $petsc_for_kernel ] || [ "`grep 'define MPI_INIT_NEEDS_MPIRUN' $petsc_for_kernel 2>/dev/null`" != "" ]
   then
      if [ -f $NOM.data ]
      then
	 USE_MPIRUN=$USE_PETSC
      else
	 USE_MPIRUN=1
      fi
   fi
fi

# Si l'on a un gestionnaire de batch (soumission!=999 et que USE_MPIRUN est mis avec NB_PROCS=1, alors soumission est mis a 1
#[ $soumission != 999 ] && [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 1 ] && soumission=1
# pour pouvoir utiliser le debogueur sur la frontale
[ "$prod" = 1 ] && [ $soumission != 999 ] && [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 1 ] && soumission=1

# Pour eviter un message d'erreur semget depuis la compilation de MPICH en shared memory
# on vide la table des semaphores (voir la raison dans lib/src/LIBMPI/Installer_mpich)
# Attention! cleanipcs tue les tous les processes paralleles en cours utilisant cette table donc les calculs TRUST!
# C'est pourquoi on fait un test sur les mpirun tournant...
[ -f $MPI_ROOT/sbin/cleanipcs ] && [ "`ps -fl -U $me | grep 'mpirun ' | grep TRUST_mpich | grep -v grep | grep -v $$`" = "" ] && $MPI_ROOT/sbin/cleanipcs

# Surcharge de la queue
[ "$queue_choisie" != "" ] && queue=$queue_choisie 
[ "$queue" != "" ] && echo "Partition $queue selected (soumission=$soumission ; NB_PROCS=$NB_PROCS ; USE_MPIRUN=$USE_MPIRUN)."

###############################
# Soumission batch interactif #
###############################
sub_file=.sub_file_$NOM
if [ "$create_sub_file" ]
then
   sub_file=sub_file && [ -f sub_file ] && mv -f sub_file sub_file.old
   echo "***************************************************"
   echo "Submission file $sub_file created but not submitted."
   echo "You can modify it, then submit the job with the command:"
fi
rm -f $sub_file
if [ $NB_PROCS -ge $soumission ]
then
   ###########################################
   # En test du sub_file selon le gestionnaire 
   ###########################################
   case $sub in
   	SLURM)
		echo "#!/bin/bash"					>> $sub_file	# Shell
		echo "#SBATCH -J $NOM" 					>> $sub_file	# Job name
		[ "$queue" != "" ] && echo "#SBATCH -p $queue"		>> $sub_file	# Partition
		[ "$qos" != "" ] && echo "#SBATCH --qos=$qos"		>> $sub_file	# Quality of service
		echo "#SBATCH -t $cpu"					>> $sub_file	# Time in minutes
		echo "#SBATCH -o myjob.%j.o"				>> $sub_file	# Output log
		echo "#SBATCH -e myjob.%j.e"				>> $sub_file	# Error log
		#[ "$project" != "" ] && echo "#SBATCH -A $project"	>> $sub_file	# Account
		[ "$project" != "" ] && echo "#SBATCH --constraint=$project" >> $sub_file	# Account
		echo "#SBATCH -n $NB_PROCS"				>> $sub_file	# Number of tasks
		[ "$noeuds" != "" ] && echo "#SBATCH -N $noeuds"        >> $sub_file    # Number of nodes
		[ "$cpus_per_task" != "" ] && echo "#SBATCH -c $cpus_per_task"	>> $sub_file	# Number of cores per task	
		[ "$node" = 1 ] && echo "#SBATCH --exclusive"		>> $sub_file	# Exclusive use of nodes during production run	
		[ "$ram" != "" ] && echo "#SBATCH --mem=$ram"           >> $sub_file    # Real memory required per node in MegaBytes
		echo "set -x"				 		>> $sub_file 
		echo "cd \$SLURM_SUBMIT_DIR" 				>> $sub_file    # Submit directory for reprise_auto script
		;;
   	POE)
		echo "#!/bin/bash" 					>> $sub_file
		echo "#@ job_name=$NOM"					>> $sub_file
		[ "$queue" != "" ] && echo "#@ class=$queue"		>> $sub_file
		echo "#@ wall_clock_limit=$cpu"				>> $sub_file
		echo "#@ output=myjob.\$(jobid).o"			>> $sub_file
		echo "#@ error=myjob.\$(jobid).e"			>> $sub_file
		#echo "#@ job_type=parallel"				>> $sub_file
		#echo "#@ network.MPI=sn_all,,us"			>> $sub_file
		#echo "#@ node_topology=island"				>> $sub_file
		#echo "#@ island_count=`echo "1+($NB_PROCS-1)/8192" | bc`" >> $sub_file # ceil($NB_PROCS/8192)
		#echo "#@ energy_policy_tag=NONE"			>> $sub_file
		#echo "#@ queue"					>> $sub_file
		echo "#@ total_tasks=$NB_PROCS"				>> $sub_file
		#echo "#@ node=`echo "1+($NB_PROCS-1)/16" | bc`" 	>> $sub_file # ceil($NB_PROCS/16)
		[ "$noeuds" != "" ] && echo "#@ node=$noeuds"		>> $sub_file 
		[ "$node" = 1 ] && echo "#@ node_usage=not_shared"	>> $sub_file
		[ "$ram" != "" ] && echo "#@ requirements=(Memory >= $ram)" >> $sub_file
		[ "$cpus_per_task" != "" ] && echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		#echo "#@ initialdir=$ici"				>> $sub_file
		echo "cd \$LOADL_STEP_INITDIR" 				>> $sub_file
		;;		
   	LSF)
	 	echo "#BSUB -J $NOM"				>> $sub_file
      		[ "$queue" != "" ] && echo "#BSUB -q $queue" 	>> $sub_file
      		echo "#BSUB -W $cpu" 				>> $sub_file 
		echo "#BSUB -o myjob.%J.o" 			>> $sub_file
		echo "#BSUB -e myjob.%J.e" 			>> $sub_file 
		echo "#BSUB -n $NB_PROCS"			>> $sub_file
		[ "$node" = 1 ] && echo "#BSUB -x"		>> $sub_file
      		[ "$ram" != "" ] && echo "#BSUB -M $ram" 	>> $sub_file
		[ "$cpus_per_task" != "" ] && echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		echo "cd \$LS_SUBCWD" 				>> $sub_file
 		;;
	CCC)
		echo "#!/bin/bash" 						>> $sub_file 
		echo "#MSUB -r $NOM" 						>> $sub_file 
		[ "$queue" != "" ] && echo "#MSUB -q $queue"			>> $sub_file 
		[ "$qos" != "" ] && echo "#MSUB -Q $qos"			>> $sub_file 
		[ "`echo $cpu | grep :`" != "" ] && echo "#BSUB -W $cpu" 	>> $sub_file # Exprime en HH:MM:SS !!! BSUB !!!
		[ "`echo $cpu | grep :`" = "" ] && echo "#MSUB -T $cpu" 	>> $sub_file # Exprime en SSSSS      	
		echo "#MSUB -o myjob.%J.o"					>> $sub_file
		echo "#MSUB -e myjob.%J.e" 					>> $sub_file
		[ "$project" != "" ] && echo "#MSUB -A $project" 		>> $sub_file 
		echo "#MSUB -E \"--no-requeue\""            			>> $sub_file # Prevent from restart
		echo "#MSUB -n $NB_PROCS" 					>> $sub_file 
		[ "$noeuds" != "" ] && echo "#MSUB -N $noeuds" 			>> $sub_file 
		[ "$cpus_per_task" != "" ] && echo "#MSUB -c $cpus_per_task"	>> $sub_file
		[ "$node" = 1 ] && echo "#MSUB -x"				>> $sub_file	# Exclusive use of nodes during production run	
		[ "$ram" != "" ] && echo "#MSUB -M $ram" 			>> $sub_file 
		[ "$espacedir" != "" ] && echo "#MSUB -m $espacedir"	>> $sub_file 
		echo "set -x"				 			>> $sub_file 
		echo "cd \$BRIDGE_MSUB_PWD" 					>> $sub_file
 		;;
	SGE)
	 	echo "#$ -N $NOM"				>> $sub_file
      		[ "$queue" != "" ] && echo "#$ -q $queue" 	>> $sub_file
		echo "#$ -l h_rt=$cpu"                          >> $sub_file
		echo "#$ -o myjob.%J.o"                         >> $sub_file
		echo "#$ -e myjob.%J.e"                         >> $sub_file
		#echo "#$ -cwd" 				>> $sub_file
		#echo "#$ -S /bin/bash"				>> $sub_file
		#[ "$balise" != "" ]	&& echo $balise		>> $sub_file
		[ "$taches" != "" ] && echo "#$ -pe $taches"	>> $sub_file
		[ "$node" = 1 ] && echo "#$ -l exclusive"	>> $sub_file
		[ "$ram" != "" ] && echo "#$ -l mem_free=$ram"  >> $sub_file
		[ "$cpus_per_task" != "" ] && echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		echo "cd \$SGE_O_WORKDIR" 			>> $sub_file
		;;	
	NQS)
	 	echo "#QSUB -r $NOM"		>> $sub_file
		echo "#QSUB -lt $cpu"		>> $sub_file
		echo "#QSUB -n $NB_PROCS" 	>> $sub_file
		[ "$cpus_per_task" != "" ] && echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
                echo "cd $ici" 			>> $sub_file
		;;
	PBS)
		echo "#!/bin/bash"                                      >> $sub_file    # Shell (sh ou bash)
		echo "#PBS -N `echo $NOM | cut -c 1-15`"                >> $sub_file    # Job name
		[ "$queue" != "" ] && echo "#PBS -q $queue"             >> $sub_file    # Partition
		[ "$qos" != "" ] && echo "#PBS -l qos=$qos"             >> $sub_file    # Quality of service
		echo "#PBS -l walltime=$cpu"                            >> $sub_file    # Time in minutes
		echo "#PBS -o myjob.%J.o"                               >> $sub_file    # Output log
		echo "#PBS -e myjob.%J.e"                               >> $sub_file    # Error log
		echo "#PBS -l nodes=$noeuds:ppn=$taches"                >> $sub_file    # Number of nodes and tasks
		#echo "#PBS -l ppn=$taches"      		        >> $sub_file    # Number of tasks
		#echo "#PBS -l nodes=$noeuds"           		>> $sub_file    # Number of nodes	
		#[ "$node" = 1 ] && echo "#PBS -l naccesspolicy=singlejob" >> $sub_file	# Exclusive use of nodes during production run	
		[ "$ram" != "" ] && echo "#PBS -l mem=$ram"             >> $sub_file    # Real memory required per node in MegaBytes
		[ "$cpus_per_task" != "" ] && echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
		echo "cd \$PBS_O_WORKDIR" 				>> $sub_file
		;;
	*) echo "sub=$sub not planned." && exit -1
		;;
   esac	   
   #######
   # IPM #
   #######
   if [ "$ipm" = 1 ]
   then
      echo "module load ipm" 				>> $sub_file
      echo "export LD_PRELOAD=\$IPM_ROOT/lib/libipm.so" >> $sub_file
   fi
   ##########
   # VAMPIR #
   ##########
   if [ "$VAMPIRTRACE_ROOT" != "" ]
   then
      echo "export VT_IOTRACE=yes" 	>> $sub_file
      echo "export VT_MAX_FLUSHES=0" 	>> $sub_file
   fi
   ######################
   # Commandes de calculs
   ######################
   echo "[ -f ld_env.sh ] && . ./ld_env.sh # To load an environment file if necessary" >> $sub_file
   echo "source $TRUST_ROOT/env_TRUST.sh" >> $sub_file
   if [ "$create_sub_file" = 1 ]
   then
      OUTPUT=$NOM
   else
      # En interactif OUTPUT=.$NOM et non OUTPUT=$NOM car sinon conflit avec lance_test (trust NOM 1>$NOM.out 2>$NOM.err)
      # et blocage possible sur castor avec Baltik par exemple !!!
      OUTPUT=.$NOM   
   fi
   if [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 0 ]
   then
      echo "$exec $NOM $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
   else
      if [ "$mpirun" != "" ]
      then
         if [ "$sub" = "SLURM" ]
	 then
            echo "$mpirun $machinefile $exec $NOM \$SLURM_NTASKS $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
         elif [ "$sub" = "CCC" ]
	 then
            echo "$mpirun $machinefile $exec $NOM \$BRIDGE_MSUB_NPROC $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
	 else
            echo "$mpirun $machinefile $exec $NOM $NB_PROCS $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
	 fi
      else
         echo "$TRUST_ROOT/bin/mpirun.sh -np $NB_PROCS $machinefile $exec $NOM $NB_PROCS $PETSC_OPTIONS 1>$OUTPUT.out 2>$OUTPUT.err" >> $sub_file
      fi
   fi   
   #######
   # IPM #
   #######
   if [ "$ipm" = 1 ]
   then
      echo "report=\`ls -rt triou.*.*.0 | tail -1\`" >> $sub_file
      echo "ipm_parse -full \$report 1>>$OUTPUT.out 2>>$OUTPUT.err" >> $sub_file
      echo "ipm_parse -html \$report" >> $sub_file
   fi   
   if [ "$create_sub_file" ]
   then
      case $sub in
        SLURM) echo "sbatch $sub_file";;
      	POE) echo "llsubmit $sub_file";;
      	LSF) echo "bsub < $sub_file";;
	CCC) echo "ccc_msub $sub_file";;
	SGE) echo "qsub $sub_file";;
	NQS) echo "qsub $sub_file";;
	PBS) echo "qsub $sub_file";;
      esac
      echo "***************************************************"
      exit
   fi
   if [ "`type qstat 1>/dev/null 2>&1;echo $?`" != 0 ]
   then
      # Commande qstat non trouvee, elle est necessaire pour la suite
      echo "No command qstat found for listing jobs..."
      qstat
      exit -1
   fi   
   ##############################################
   # Soumission du sub_file selon le gestionnaire 
   ##############################################
   case $sub in
   	SLURM)	sbatch_interactif;;
   	POE) 	llsubmit -s $sub_file;;
   	LSF) 	cat $sub_file | bsub -I;;
	CCC) 	ccc_msub_interactif;;
	SGE) 	qsub -S /bin/bash -sync yes $sub_file;;
	NQS) 	qsub -I $sub_file;;
	PBS) 	qsub_interactif;;
   esac	
   err=$?   
   if [ "$VALGRIND" = "1" ] || [ "$VALGRIND_STRICT" = "1" ] || [ "$VALGRIND_GDB" = "1" ]
   then
     if [ "`awk '/ERROR SUMMARY/ {errs+=$4} END {print errs}' $OUTPUT.err $OUTPUT.out tmp_log*`" != "0" ]
     then
        exit -1
     else
        exit 0
     fi
   fi
   [ $err = 0 ] && rm -f $sub_file
   # On envoit $OUTPUT.out et $OUTPUT.err vers les bonnes sorties afin que "trust jdd 1>jdd.out 2>jdd.err" envoie ce qu'il faut dans jdd.out et jdd.err
   # A cause de platine (permission denied), on utilise plutot les chemins pointes /proc/self/fd/1 et 2
   [ -f $OUTPUT.out ] && cat $OUTPUT.out >> "/proc/self/fd/1" #cat $OUTPUT.out > "/dev/stdout"
   [ -f $OUTPUT.err ] && cat $OUTPUT.err >> "/proc/self/fd/2" #cat $OUTPUT.err > "/dev/stderr"
   # Check for TRUST calculation only (cause coupled MC2 calculation DO NOT produce this message for example):
   if [ "`grep 'Executable: ' $OUTPUT.err 2>/dev/null`" != "" ] && [ "`grep 'Arret des processes.' $OUTPUT.err`" = "" ]
   then
      err=1
   fi
   # Try to detect crashes (if it is not a TRUST binary, example PETSc test case)
   if [ "`grep 'invalid device function' $OUTPUT.err`" != "" ] || [ "`grep 'Signal: Aborted' $OUTPUT.err`" != "" ]
   then
      err=1
   fi
   exit $err
else
   [ "$cpus_per_task" != "" ] 	&& echo "Number of core per task option not supported yet on $HOST. Contact TRUST support" && exit -1
   if [ $NB_PROCS = 1 ] && [ $USE_MPIRUN = 0 ]
   then
      ###############################
      # Calcul direct en sequentiel #
      ############################### 
      run="$gdb $exec $NOM $PETSC_OPTIONS" 
   else
      ##############################
      # Calcul direct en parallele #
      ##############################     
      run="$TRUST_ROOT/bin/mpirun.sh `[ "$gdb" != "" ] && echo -gdb` -np $NB_PROCS $exec $NOM $NB_PROCS $PETSC_OPTIONS"
   fi
   if [ "$create_sub_file" ]
   then
      echo $run > $sub_file
      chmod +x $sub_file
      echo "./$sub_file"  
      echo "***************************************************"
      exit
   fi
   if [ "$TRUST_USE_Sjob" = "1" ]
       then
       # export PATH=$PATH:$TRUST_ROOT/bin/Sjob
       sub_file=s${NB_PROCS}_$NOM
       sub_file=`echo $sub_file | sed "s/\//_/g"`
       echo "#!/bin/bash" > $sub_file
       echo $run  >> $sub_file
       chmod +x  $sub_file
       $TRUST_ROOT/bin/Sjob/Salloc -n $NB_PROCS $PWD/$sub_file
       err=$?
       [ $err -eq 0 ] && rm -f $sub_file
   else
       eval $run
       err=$?
   fi
fi

[ "$log_file" != "" ] && sleep 1 && cat $(ls -rt tmp_log* | tail -$NB_PROCS)
exit $err

