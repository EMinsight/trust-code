#!/bin/bash
check_components()
{
   for Composant in $Composants
   do
      if [ ! -d $TRUST_ROOT/../Composants/$Composant ]
      then
         # Create a link for some components
	 cd $TRUST_ROOT/../Composants
	 if [ -d ../TRUST/doc/TRUST/exercices/$Composant ]
	 then
	    ln -s -f ../TRUST/doc/TRUST/exercices/$Composant .
	 fi
	 if [ -d ../Pre_Post_TRUST/Outils/$Composant/$Composant_src ]
	 then
	    ln -s -f ../Pre_Post_TRUST/Outils/$Composant/$Composant"_src" $Composant
	 fi
      fi
      if [ -d $TRUST_ROOT/../Composants/$Composant ]
      then
         cd $TRUST_ROOT/../Composants/$Composant
	 rm -f $Composant*.log
	 #Composant_log=`dirname $TRUST_ROOT`/Composants/$Composant.log
	 Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_"${*#*/}".log"
         echo "  Check `pwd`"
	 echo "    See $Composant_log"
	 (
            echo "TRUST script on $HOST the `date` ..."
            echo " "
            echo "Check $Composant Component for $TRUST_VERSION version"
            echo " "
            echo "******************************************************"
            echo " "
	    [ $TRUST_ROOT = $TRUST_ROOT_MASTER ] && export MAKEATELIER_SEVERITY=1
	    COMPOSANT_OK=0
	    # First pass, reconfigure to clean properly (in the case where the TRUST_ROOT has changed):
	    $TRUST_ROOT/bin/baltik/bin/baltik_build_configure && ./configure && make dist_clean
	    $TRUST_ROOT/bin/baltik/bin/baltik_build_configure && ./configure &&
	    make optim module_optim debug module_debug &&
	    make check_all_optim `[ $TRUST_ROOT = $TRUST_ROOT_MASTER ] && echo check_all_debug` && echo "$Composant OK" && COMPOSANT_OK=1
            echo " "
            echo "******************************************************"
            echo " "
	    echo $ECHO_OPTS "Component $Composant checked on $HOST with $TRUST_VERSION ...\c"
	    if [ "$COMPOSANT_OK" = 0 ]
	    then
	       echo $ECHO_OPTS "KO."
	       cat $Composant_log | mail_ -s\"[lance_test_nuit] check_components $Composant $TRUST_VERSION KO\" $TRUST_MAIL
	    else
	       echo $ECHO_OPTS "OK"
	    fi	    
	    echo " "
	    rm -f Run.liste
	    rm -f nuit_$Composant.html
	    rm -f $Composant_%_*.log
	    # On teste la portabilite uniquement si tout a fonctionne en local (pour eviter de bloquer d'autres PCs)
	    if [ "$COMPOSANT_OK" = 1 ] && [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	    then
               echo "Portability $Composant Component for $TRUST_VERSION version"
               echo " "
               echo "******************************************************"
               echo " "
	       # Test on cezanne63 (for SESI Debian 7.0)
	       # Test on callisto (DM2S cluster)
	       # Test on curie (CCRT cluster) 
	       # Test sur une machine valgrind 
	       valgrind_machine=`liste_machines "\-valgrind" | head -1 | awk -F. '{print $1}'`
	       liste_options="--with-efface-dir-before --with-mode=optim --check-all"
	       echo "  See `pwd`/Run.liste"
	       echo "$Composant.tar /home/pledac/Version_test_cezanne63/Composants/$Composant pledac@cezanne63 --with-trio=/home/pledac/Version_test_cezanne63/TRUST $liste_options" >> Run.liste
	       # ModeleCoeur 
	       #[ "$Composant" != ModeleCoeur ] && echo "$Composant.tar /panfs/ixion/home/triou/Version_test_callisto/Composants/$Composant triou@callisto --with-trio=/panfs/ixion/home/triou/Version_test_callisto/TRUST $liste_options" >> Run.liste
	       echo "$Composant.tar /panfs/ixion/home/triou/Version_test_callisto/Composants/$Composant triou@callisto --with-trio=/panfs/ixion/home/triou/Version_test_callisto/TRUST $liste_options" >> Run.liste
	       # ModeleCoeur had some crashes on curie for inter assemblage calculations:
	       #[ "$Composant" != ModeleCoeur ] && echo "$Composant.tar /ccc/cont002/home/den/triou/Version_test_curie-ccrt/Composants/$Composant triou@curie-ccrt --with-trio=/ccc/cont002/home/den/triou/Version_test_curie-ccrt/TRUST $liste_options" >> Run.liste
	       echo "$Composant.tar /ccc/cont002/home/den/triou/Version_test_curie-ccrt/Composants/$Composant triou@curie-ccrt --with-trio=/ccc/cont002/home/den/triou/Version_test_curie-ccrt/TRUST $liste_options" >> Run.liste
	       # valgrind too slow (try again the 21/11/14 for 1.7.0):
	       # /work/triou/ au CEA Grenoble ; /export/home/triou/ au CEA Saclay
	       #echo "$Composant.tar /work/triou/Version_test_$valgrind_machine/Composants/$Composant triou@$valgrind_machine --with-trio=/work/triou/Version_test_$valgrind_machine/TRUST $liste_options --with-valgrind" >> Run.liste
	       echo "$Composant.tar /export/home/triou/Version_test_$valgrind_machine/Composants/$Composant triou@$valgrind_machine --with-trio=/export/home/triou/Version_test_$valgrind_machine/TRUST $liste_options --with-valgrind" >> Run.liste
               echo " "
	       cat Run.liste
	       echo " "
	       echo "Call to $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste"
	       echo " "
	       $TRUST_ROOT/bin/baltik/share/baltik/bin/baltik_check_portability Run.liste & # Take care if run not with &, the second argument should be different for each project
	    fi
	 ) 1>$Composant_log 2>&1
	 echo "    `grep "Component $Composant" $Composant_log`"
         cd $TRUST_ROOT
      else
         echo "Component $Composant not found here: $TRUST_ROOT/../Composants"
      fi
   done
}

# Push to repos (called several times, once at the beginning and sometimes at the end...)
git_push()
{
   all=0 && [ "$1" = -all ] && all=1
   git_branch=`git branch 2>/dev/null | awk '($1=="*") {print $2}'`
   # git remote add official ssh://triou@sedna/applicatifs_dm2s/triou/GIT_REPOS/official/trio_u
   repos=`git remote`
   # Si branche patch_XYZ, on ne pousse pas automatiquement sur official (demande par Gauthier):
   # sauf si -all (sortie de version)
   [ "$all" != 1 ] && [ ${git_branch#patch_} != $git_branch ] && repos=`git remote | grep -v official`
   for repo in $repos
   do
      repo_log=$REP_NUIT"/git_"$repo"_"$git_branch"_"$HOST".log"
      echo "TRUST git push on $HOST the `date` ...">$repo_log
      echo>>$repo_log
      echo "  git push --tags $repo $git_branch. See $repo_log"
      git push --tags $repo $git_branch 1>>$repo_log 2>&1 || cat $repo_log | mail_ -s\"[lance_test_nuit] Error for git push $repo $git_branch\" $TRUST_MAIL	 
      cat $repo_log | tail -n +3
      [ "`cat $repo_log | tail -n +3`" != "Everything up-to-date" ] && cat $repo_log | mail_ -s\"[lance_test_nuit] git push $repo $git_branch\" $TRUST_MAIL $TRUST_PROJECT_LEADER
   done
}

############################################################################################################################################################

#########
# BEGIN #
#########
echo "****************************************************"
echo `date`
echo "Beginning of the `basename $0` script at `date '+%H:%M:%S'` from:"
echo "\$TRUST_ROOT=${0%/bin/admin/lance_test_nuit}"
echo "****************************************************"
echo " "
echo "##########################"
echo "# Initialize environment #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S'`
if [ -f ~/.profile ]
then
   echo "Call to "`echo ~`"/.profile"
   . ~/.profile 1>/dev/null 2>&1
   echo "  HOST=$HOST"
   echo "  WORKDIR=$WORKDIR"
else
   echo `echo ~`"/.profile file not exist!" && exit -1
fi
# ROOT
export TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
export TRUST_ROOT_MASTER=$TRUST_ROOT # New variable to set master workdir (master branch in git)

# On recupere les numeros de version dans le fichier RELEASE_NOTES
export old=`awk '/version/ {print $(NF-1);exit}' $TRUST_ROOT/RELEASE_NOTES`
export new=`awk '/version/ {print $4;exit}' $TRUST_ROOT/RELEASE_NOTES`
export Version=Version$new
echo " "
echo "Release notes old version: "$old
echo "Release notes new version: "$new

# DISPLAY
[ ${#DISPLAY} = 0 ] && export DISPLAY=":0"

VOBS="Doc_TRUST Pre_Post_TRUST Tests_TRUST TRUST Composants"

# List of components tested with TRUST:
# equation_convection_diffusion est un projet Baltik qui sert de tutorial a la formation developpeur.
# MPCube est supprime de la liste car teste par ailleurs sur le Kernel
#Composants="ModeleCoeur ICoCo equation_convection_diffusion MPCube" 
Composants="ModeleCoeur ICoCo equation_convection_diffusion" 

# Initialize environment TRUST:
echo " "
echo "Call to "$TRUST_ROOT"/env/trio_u.env"
. $TRUST_ROOT/env/trio_u.env #1>/dev/null 2>&1

# List of executables tested:
exec_debug=$TRUST_ROOT/exec/TRUST$COMM
exec_semi_opt=$TRUST_ROOT/exec/TRUST$COMM"_semi_opt"
exec_opt=$TRUST_ROOT/exec/TRUST$COMM"_opt"
liste_exec=$exec_debug" "$exec_semi_opt

# Initialize ftp connection:
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
. $TRUST_ROOT/bin/admin/connect_ftp -no_ftp #1>/dev/null 2>&1
echo "Public  ftp server: ftp://$TRUST_FTP/$PUBLIC"
echo "Private ftp server: ftp://$TRUST_FTP/$SECRET"
echo " "

# Backup de hostname
echo "Call to "`echo ~`"/bin/backup_pc_tma.sh via crontab"
echo "  See "`echo ~`"/bin/backup_pc_tma.log"
# NB: Now via crontab
#~/bin/backup_pc_tma.sh 1>~/bin/backup_pc_tma.log 2>&1
grep -i error ~/bin/backup_pc_tma.log
tail -n2 ~/bin/backup_pc_tma.log
echo " "

[ $HOST != $TRUST_HOST_ADMIN ] && echo "Error: You must be on $TRUST_HOST_ADMIN to do this action" && exit

export DATE=`date '+%d%m%y'`
export NUIT=1
REP_NUIT=$TRUST_ROOT/NUIT
REP_HIST=$TRUST_ROOT/HIST
MESSAGES_NUIT=$REP_NUIT/MESSAGES_NUIT

# On fait le menage :
echo "Cleaning of $REP_NUIT directory"
rm -f $REP_NUIT/CR_* $REP_NUIT/PERF_* $REP_NUIT/MAKE_* $REP_NUIT/*.log
rm -f $REP_NUIT/rsync_include_from $REP_NUIT/NUIT.html
rm -f $REP_NUIT/os $REP_NUIT/CC $REP_NUIT/CR
rm -f $MESSAGES_NUIT
# On cree :
[ ! -d $REP_NUIT ] && mkdir $REP_NUIT
[ ! -d $REP_HIST ] && mkdir $REP_HIST
ls $REP_NUIT
echo "<--- End at "`date '+%H:%M:%S'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###########################"
echo "# Work on the new version #"
echo "###########################"

###################################
# Debut du travail sur la version #
###################################
echo " "
echo "############################"
echo "# Create the documentation #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S'`
credoc_log=$REP_NUIT/credoc_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/KSH/credoc"
echo "  See $credoc_log"
echo "TRUST documentation creation on $HOST the `date` ...">$credoc_log
echo>>$credoc_log
$TRUST_ROOT/bin/KSH/credoc 1>>$credoc_log 2>&1
echo "<--- End at "`date '+%H:%M:%S'`
echo " "
echo "######################"
echo "# Update the sources #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S'`
cd $TRUST_ROOT
# Mise a jour des includes, des makefile de TRUST
config_log=$REP_NUIT/configure_$HOST.log
echo "Call to "$TRUST_ROOT"/configure"
echo "  See $config_log"
echo "TRUST configuration on $HOST the `date` ...">$config_log
echo>>$config_log
./configure 1>>$config_log || exit -1
grep -i error $config_log
grep KO $config_log
tail -n5 $config_log | head -n1
echo " "
echo "Call to "$TRUST_ROOT"/env/env_TRUST.sh"
source env/env_TRUST.sh #1>/dev/null 2>&1

# Verifie la qualite de la version
# Verifie si plusieurs classes ne sont pas instanciees avec le meme nom
# Verification de l'unicite du nom des classes dans les macros implemente_...
instanc_log=$REP_NUIT/verifie_instanciable_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/verifie_instanciable"
echo "  See $instanc_log"
echo "TRUST instanciable check on $HOST the `date` ...">$instanc_log
echo>>$instanc_log
verifie_instanciable 1>>$instanc_log 2>&1
grep -i error $instanc_log
tail -n1 $instanc_log 
# Verifie la validite de la classe mere dans les instanciations
# Verification du nom de la classe pere dans les macros implemente_...
verif_log=$REP_NUIT/Verifie_pere_$HOST.log
echo " "
echo "Call to "$TRUST_ROOT"/bin/KSH/Verifie_pere"
echo "  See $verif_log"
echo "TRUST father class check on $HOST the `date` ...">$verif_log
echo>>$verif_log
Verifie_pere 1>>$verif_log 2>&1
verif_error=$?
tail -n1 $verif_log
if [ $verif_error != 0 ]
then
   cat $verif_log | mail_ -s\"[lance_test_nuit] Verifie_pere KO on $HOST:$TRUST_ROOT\" $TRUST_MAIL $TRUST_PROJECT_LEADER
fi
echo>>$verif_log
cat $TRUST_TMP/Verifie_pere/LOG>>$verif_log 

# Marque la version dans MAIN.cpp et mon_main.cpp
echo " "
for MAIN in $TRUST_ROOT/src/MAIN/MAIN.cpp $TRUST_ROOT/src/MAIN/mon_main.cpp
do
   echo "Mark "$MAIN
   CHECKOUT $MAIN 1>/dev/null 2>&1
   version=`$TRUST_Awk '/version :/ {print $4}' $MAIN`
   build=`$TRUST_Awk '/build :/ {print $4}' $MAIN`
   echo $ECHO_OPTS "1,$ s?version : $version?version : $new?g\nw" | ed $MAIN 1>/dev/null 2>&1
   echo $ECHO_OPTS "1,$ s?build : $build?build : $DATE?g\nw" | ed $MAIN 1>/dev/null 2>&1
   CHECKIN $MAIN 1>/dev/null 2>&1
done
index=$TRUST_ROOT/index.html
version=`$TRUST_Awk '/ Version / {print $4}' $index`
echo $ECHO_OPTS "1,$ s?$version?$new?g\nw $index.new" | ed $index 1>/dev/null 2>&1
if [ "`diff $index $index.new`" != "" ]
then
   echo "Mark "$index
   CHECKOUT $index
   cat $index.new > $index
fi
rm -f $index.new
echo " "


[ ! -d $TRUST_ROOT/../.git ] && echo "Error: You must have $TRUST_ROOT/../.git directory to do this action" && exit

# Update Git repos #
####################
# Must be done BEFORE envoie_TRUST_arch (git_cron or git_ssh process)
(
   # Assume unchanged some files (big one with a lot of changes):
   cd $TRUST_ROOT/..
   echo "Update Git repos "`pwd`
   for assume_inchanged in Doc_TRUST/doc/Coverage/html.tgz Doc_TRUST/doc/Coverage/cpp.gcov.tar.gz Doc_TRUST/doc/Coverage/list_methodes.gz Doc_TRUST/doc/Coverage/dico.pkl.gz Doc_TRUST/doc/Coverage/list_methodes_non_appelees.gz
   do
      if [ ! -f $assume_inchanged ]
      then
         echo | mail_ -s\"[lance_test_nuit] File $assume_inchanged not found, fix lance_test_nuit. \" $TRUST_MAIL
      else
         # Ignore the changes of the specified files
         git update-index --assume-unchanged $assume_inchanged
      fi
   done
   # List untracked files:
   echo "  List of files untracked with git update-index --assume-unchanged:"
   git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'
   cd - 1>/dev/null 2>&1
   # Push to repos
   echo " "
   echo "Call git_push"
   git_push
)
echo "<--- End at "`date '+%H:%M:%S'`
echo " "
echo "#######################################"
echo "# Send the sources to remote machines #"
echo "#######################################"
echo "---> Begin at "`date '+%H:%M:%S'`
(
envoie_log=$REP_NUIT/envoie_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_TRUST_arch"
rm -f $REP_NUIT/rsync_include_from
echo "  See $envoie_log"
echo "TRUST script on $HOST the `date` ...">$envoie_log
echo>>$envoie_log
envoie_TRUST_arch 1>>$envoie_log 2>&1
grep -i delete $envoie_log | head -n1
grep KO $envoie_log
grep error $envoie_log
mv -f rsync_*.log $REP_NUIT/.
mv -f rsync_include_from $REP_NUIT/.
mv -f ssh_*.log $REP_NUIT/.
) # & Pas en background pour voir ce qui fait planter le serveur X
echo "<--- End at "`date '+%H:%M:%S'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "###############################################"
echo "# Compile and verify the old and new versions #"
echo "###############################################"
( 
  # On allege le nombre de versions compilees:
  for vue in git/Livraison git/Maintenance git/Kernel
  do
     if [ -d $WORKDIR/$vue ]
     then
	# Git workdir
	TRUST_ROOT=$WORKDIR/$vue/TRUST
	cd $TRUST_ROOT
        echo " "
        echo "#############################"
        echo "# On workdir: "$TRUST_ROOT
        echo "#############################"
        echo "---> Begin at "`date '+%H:%M:%S'`
	if [ $vue = git/Kernel ]
	then
           # Kernel desormais workdir Git:
	   #rebase_log=`mktemp_`
	   rebase_log=$REP_NUIT"/rebase_"$HOST"_"${vue#*/}".log"
	   echo "Call git rebase master"
	   echo "  See $rebase_log"
           echo "git rebase on $HOST the `date` ...">$rebase_log
           echo>>$rebase_log
	   git commit ../Doc_TRUST/doc/.dico src/CMakeLists.txt src/MAIN/instancie_appel.h src/MAIN/instancie_appel_c.h -m"Commit in Kernel before git rebase master" --u=no 1>>$rebase_log 2>&1
	   git rebase master 1>>$rebase_log 2>&1
	   rebase_error=$?
	   if [ $rebase_error != 0 ]
	   then
	      deleted_item=deleted_item
	      while [ $rebase_error != 0 ] && [ "$deleted_item" != "" ]
	      do
	         for deleted_item in `git status | awk '/deleted by them/ || /added by us/ {print $5}'`
	         do
		    git rm $deleted_item 1>>$rebase_log 2>&1
	         done
	         git rebase --continue 1>>$rebase_log 2>&1
	         rebase_error=$?
		 if [ "`git rebase --continue 2>&1`" = "No rebase in progress?" ]
		 then
		    rebase_error=0
		 fi
	      done
	   fi
	   if [ $rebase_error != 0 ]
	   then
	      cat $rebase_log | mail_ -s\"[lance_test_nuit] Error when rebasing $vue workdir. Check.\" $TRUST_PROJECT_LEADER $TRUST_MAIL
	   fi
	   grep -i error $rebase_log
	   tail -n1 $rebase_log
	   echo " "
	   #rm -f $rebase_log
	   # Delete non Kernel tests if any:
	   cd $TRUST_ROOT/tests
	   NonKernelTests=`find * -type d | grep -v Kernel | grep "/"`
	   if [ "$NonKernelTests" != "" ]
	   then
	      echo "Call git rm no $vue tests..."
	      for NonKernelTest in $NonKernelTests
	      do
		 git rm -r $NonKernelTest
	      done
	      git commit --all -m"Non Kernel tests suppressed from the branch Kernel."
	      echo " "
	   fi
	   cd - 1>/dev/null 2>&1
	fi
	echo "Call to configure $vue version in `pwd`"
	./configure 1>/dev/null 2>&1
	# A supprimer quand la version Maintenance sera passee en 1.7.1
	if [ $vue = git/Maintenance ] # temporarily
	then
           source bin/Init_TRUST 1>/dev/null 2>&1 # temporarily
        else
	   source env/env_TRUST.sh 1>/dev/null 2>&1
	fi
	###################################################
	# Boucle sur les differentes options de compilation
	###################################################
	for OPT in _semi_opt_ _opt_ _ _opt_pg_ _opt_gcov_ _opt_avx_
	do
	   # A supprimer quand la version Maintenance sera passee en 1.7.1
	   if [ $vue = git/Maintenance ] # temporarily
	   then
              case $OPT in
	      _semi_opt_) TYPE="";;
	      _opt_) TYPE="optim";;
	      _) TYPE="debug";;
	      _opt_pg_) TYPE="prof";;
	      _opt_gcov_) TYPE="gcov";;
	      _opt_avx_) TYPE="optim_avx";;
              *) echo $OPT not coded in $0;  exit -1 ;;
	      esac;
	   else
              case $OPT in
	      _semi_opt_) TYPE="semi_opt";;
	      _opt_) TYPE="opt";;
	      _) TYPE="debug";;
	      _opt_pg_) TYPE="prof";;
	      _opt_gcov_) TYPE="gcov";;
	      _opt_avx_) TYPE="opt_avx";;
              *) echo $OPT not coded in $0;  exit -1 ;;
	      esac;
	   fi
	   OPT=${OPT%_} # <=> OPT=${OPT::-1}
	   echo " "
	   make_log=$REP_NUIT"/MAKE_TRUST"$COMM"_"$TYPE"_"$TRUST_ARCH"_"$HOST"_"${vue#*/}
           echo "Call to make $TYPE on `pwd`";
	   echo "  See $make_log"
           echo "TRUST make on $HOST the `date` ...">$make_log
           echo>>$make_log
	   make $TYPE 1>>$make_log 2>&1
	   grep -i error $make_log
	   grep -i Stop $make_log
	   grep KO $make_log
	   if [ "$OPT" = "_semi_opt" ]
	   then
	      if [ $TRUST_ROOT = $TRUST_ROOT_MASTER ]
	      then
                 # Force une compilation statique pour:
                 # a) Instanciation manquante
                 # b) Sauve un exec en le zippant sous NUIT
		 echo " "
		 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
                 cd $TRUST_ROOT/MonoDir_mpi$OPT/src
		 cmake . -DCOMPIL_DYN=OFF
   		 tmp=`mktemp_`
		 make 1>>$tmp 2>&1
		 tail -n2 $tmp
		 rm -f $tmp
                 gzip -c $exec > $REP_HIST/`basename $exec`"."$DATE".gz"
		 cd $TRUST_ROOT
		 echo " "
	         echo "Save "$REP_HIST/`basename $exec`"."$DATE".gz"
	      elif [ $vue = git/Maintenance ]
	      then
	         echo " "
	         echo "Special treatment..."
	         ################################
	         # Travaux sur la vue Maintenance
		 ################################
		 checkin_log=$REP_NUIT"/checkin_patch_"$HOST"_"${vue#*/}".log"
                 echo "Call to "$TRUST_ROOT"/bin/admin/checkin_patch.ct"
                 echo "  See $checkin_log"
                 echo "TRUST checkin patch on $HOST the `date` ...">$checkin_log
		 $TRUST_ROOT/bin/admin/checkin_patch.ct 1>>$checkin_log 2>&1
		 wc -l $checkin_log
		 [ "`cat $checkin_log | tail -n +2`" != "" ] && cat $checkin_log | mail_ -s\"[checkin_patch.ct] Changes in the $TRUST_VERSION patch branch\" $TRUST_MAIL $TRUST_PROJECT_LEADER
		 #######################
		 # Construction du patch
		 #######################
		 patch_version=`awk '/version/ && /Release notes/ {print $4;exit}' RELEASE_NOTES`
		 rm -f $TRUST_TMP/patch
		 GRAVAGE=$WORKDIR/A_GRAVER_CD_TRUST
		 patch=$GRAVAGE/Patch$patch_version".tar" && rm -f $patch
		 echo " "
		 echo "Construction of the $patch patch..."
		 echo "from `pwd`"
		 (    
		    (
		       cd bin;tar cf $patch Installer_TRUST README_INSTALL linux_install_tools*.tgz
		    )
		    cd ..
		    # Git (On ne scrute que les VOBs TRUST):
		    cd $TRUST_ROOT
		    git_push
		    echo "  Files contained in $TRUST_TMP/patch"
		    echo "    See $TRUST_TMP/patch_files"
		    git diff --name-only v$TRUST_VERSION | awk -F/ '{s=$2;for (i=3;i<=NF;i++) s=s"/"$i;print s}' > $TRUST_TMP/patch_files
		    if [ -s $TRUST_TMP/patch_files ]
		    then
		       for file in `cat $TRUST_TMP/patch_files`
		       do
		          if [ -f $file ]
		          then
			     # echo $file
        		     tar rf $TRUST_TMP/patch $file
        		  fi
		       done
		    fi
		    echo "  Files compressed in $patch"
		    cd $TRUST_TMP;tar rf $patch patch
		 )
		 cd $TRUST_ROOT
		 # Envoi immediat sur ftp.cea.fr
                 echo "  Call to "$TRUST_ROOT"/bin/admin/connect_ftp"
                 . $TRUST_ROOT/bin/admin/connect_ftp
                 echo "  Call to "$TRUST_ROOT"/bin/admin/cp_ftp"
		 $TRUST_ROOT/bin/admin/cp_ftp $patch $PUBLIC/patch
		 # Mise a jour des versions patchees
		 echo " "
                 echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
		 liste_machines updated
		 for machine in `liste_machines updated`
		 do
		    (
		    install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}'`"_"${vue#*/}".log"
		    echo "-> Start of Installer_TRUST.ssh $machine $patch_version -patch -compile..."
	            echo "  See $install_patch_log"
		    )
		 done
		 for machine in `liste_machines updated`
		 do
		    (
		    install_patch_log=$REP_NUIT"/install_patch_"`echo $machine | awk -F"." '{print $1}'`"_"${vue#*/}".log"
                    echo "TRUST script on $HOST the `date` ...">$install_patch_log
		    echo>>$install_patch_log
		    $TRUST_ROOT/bin/admin/Installer_TRUST.ssh $machine $patch_version -patch -compile 1>>$install_patch_log 2>&1
		    if [ $? != 0 ] || [ "`grep :error $install_patch_log | grep -iv warning | grep -v TRIOXDATA | grep -v Gmsh`" != "" ]
		    then
                       cat $install_patch_log | mail_ -s\"[lance_test_nuit] Failed to install patch version on $machine\" $TRUST_MAIL
		    fi
		    ) &
		    # Quels sont les conflits ?
		 done
	         echo "End special treatment."
	      fi
	   fi
	done
	########################
	# Check non regression #
	########################
	if [ $vue = git/Maintenance ] || [ $vue = git/Kernel ]
	then
	   lance_test_log=$REP_NUIT"/lance_test_"$HOST"_"${vue#*/}".log"
	   echo " "
	   echo "-> Start of exec=$exec_opt triou -check all"
           echo "  See $lance_test_log"
           echo "TRUST script on $HOST the `date` ...">$lance_test_log
	   echo>>$lance_test_log
	   # Reduce priority with nice:
	   exec=$exec_opt nice -n 19 $TRUST_ROOT/bin/triou -check all 1>>$lance_test_log 2>&1 &
	fi
	###############################
	# Verification des composants #
	###############################
	if [ $vue = git/Maintenance ]
	then
	   echo " "
	   echo "Call check_components for $TRUST_VERSION version from `pwd`"
	   check_components $vue
	fi
	if [ $vue = git/Livraison ]
	then
	   ##########################################
 	   # Merge needed from patch branch under Git
 	   ##########################################
	   to_merge=`mktemp_`
  	   patch_branch=`cd $WORKDIR/git/Maintenance/;git rev-parse --abbrev-ref HEAD`
	   echo " "
 	   echo "Call `pwd`/git diff --name-status master...$patch_branch"
 	   git diff --name-status master...$patch_branch 1>$to_merge
	   cat $to_merge
 	   [ -s $to_merge ] && cat $to_merge | mail_ -s\"[lance_test_nuit] Some stuff to merge in master from $patch_branch with command: fusion.git $patch_branch\" $TRUST_MAIL
 	   rm -f $to_merge
	fi
        echo "<--- End at "`date '+%H:%M:%S'`
     fi
  done
)
TRUST_ROOT=${0%/bin/admin/lance_test_nuit}
cd $TRUST_ROOT
source env/env_TRUST.sh 1>/dev/null 2>&1
echo " "
echo "------------------------------------------------------"
echo " "
echo "########################"
echo "# Test the new version #"
echo "########################"

####################################################
# Lancement des etudes sur une machine de production
####################################################
ETUDES=$WORKDIR/git/Etudes
echo " "
echo "##################"
echo "# On study cases #"
echo "##################"
echo "---> Begin at "`date '+%H:%M:%S'`
etude_activation=1
etude_test=0
disable_etudes=~/disable_etudes && [ -f $disable_etudes ] && etude_test=1 && rm -f $disable_etudes
if [ "$etude_activation" = 1 ] 
then
   cd $ETUDES
   if [ $? != 0 ]
   then
      echo "Error: $ETUDES not found !"
      echo "You should create a git repo for Etudes and change the run script"
      echo "or for the moment, you can create a link to Etudes directory."
# seulement si le script run de la veille est termine (ie run_Etudes.log deplace dans $REP_NUIT)
   else 
      if [ ! -f run_Etudes.log ]
      then
         echo "-> Start of "$ETUDES"/run -all"
	 touch $ETUDES/run_Etudes.log
         #if [ "`date '+%u'`" -lt 5 ] # la semaine
         #if [ "`date '+%u'`" = 2 ] || [ "`date '+%u'`" = 4 ] # un jour sur deux : mardi et jeudi
	 if [ "$etude_test" = 1 ]
	 then
            echo "  See $REP_NUIT/run_Mistra_*.log"
            echo "TRUST script on airain the `date` ...">run_Mistra_airain.log
	    echo>>run_Mistra_airain.log
            ./run Validation/Mistra -adr airain.ccc.cea.fr 1>>run_Mistra_airain.log 2>&1 &
            echo "TRUST script on curie the `date` ...">run_Mistra_curie.log
	    echo>>run_Mistra_curie.log
            ./run Validation/Mistra -adr curie-ccrt.ccc.cea.fr 1>>run_Mistra_curie.log 2>&1 &
            echo "TRUST script on callisto the `date` ...">run_Mistra_callisto.log
	    echo>>run_Mistra_callisto.log
           ./run Validation/Mistra -adr callisto.intra.cea.fr 1>>run_Mistra_callisto.log 2>&1 &
	 else
            echo "  See $REP_NUIT/run_Etudes.log"
            echo "TRUST script from $HOST the `date` ...">run_Etudes.log
	    echo>>run_Etudes.log
            (./run -all 1>>run_Etudes.log 2>&1) &
	 fi
      else
         echo "NOT launched because $ETUDES/run script not finished"
         echo "  See $ETUDES/run_Etudes.log"
      fi
   fi
else
   echo "NOT executed"
fi
echo "<--- End at "`date '+%H:%M:%S'`

#####################################
# Lancement des tests sur Livraison #
#####################################
cd $TRUST_ROOT
touch $REP_HIST/lance_test.$DATE
echo "TRUST script on $HOST the `date` ...">$REP_HIST/lance_test.$DATE
echo " "
echo "##########################"
echo "# On no-regression tests #"
echo "##########################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "  See $REP_HIST/lance_test.$DATE"
for exec in $liste_exec
do
   cd $TRUST_ROOT
   TYPE=""
   [ $exec = "$exec_debug" ] && TYPE=debugged && PERF=$REP_NUIT/PERF_`basename $exec`"_debug_"$TRUST_ARCH"_"$HOST
   [ $exec = "$exec_semi_opt" ] && TYPE=semi-optimized && PERF=$REP_NUIT/PERF_`basename $exec`_$TRUST_ARCH"_"$HOST
   echo " "
   echo "MODE: $TYPE (exec=$exec)"
   echo "TRUST performance on $HOST the `date` ...">$PERF
   echo "--------------------------------------------------------" >> $PERF
   echo "hostname "$HOST >> $PERF
   OS="Os "`uname -s` && [ $TRUST_ARCH = linux ] && OS=$OS" "`cat /proc/cpuinfo | $TRUST_Awk '/MHz/ {print $4"Mhz";exit}'`
   echo $OS >> $PERF
   echo "release "`uname -r` >> $PERF
   echo "model "`uname -m` >> $PERF
########################################################
# La nuit, lance_test est lance avec l'executable exec :
########################################################
   if [ -f $exec ] && [ "`$exec 2>&1 | grep TRUST`" != "" ]
   then
      taille=`ls -la $exec | $TRUST_Awk '{print $5}'`
      taille=`echo $ECHO_OPTS "scale=1\n$taille/1000000" | bc -l`
      #type=`echo $taille | $TRUST_Awk '{type="Statique";if ($1<=2) type="Dynamique";print type}'`
      type=`ldd $exec | $TRUST_Awk 'END {type="Statique";if (NR>20) type="Dynamique";print type}'`
      if [ $type = Statique ]
      then
         echo "size "$taille" "$type >> $PERF
      elif [ $type = Dynamique ]
      then
         sl=`ls -la $TRUST_ROOT/lib/lib*.s* | $TRUST_Awk 'BEGIN {i=0} {i+=$5} END {print i}'`
         #echo "sl="$sl
         sl=`echo $ECHO_OPTS "scale=1\n$sl/1000000" | bc -l`
         #echo "sl="$sl
         echo "size "$taille"+"$sl" "$type >> $PERF
      fi
      echo "--------------------------------------------------------" >> $PERF
      echo "exec "$exec >> $PERF
      #######################################
      ### CHOIX DU NOMBRE DE TESTS PASSES ###
      N=0
      [ $exec = "$exec_debug" ] && N=VAHL_DAVIS
      #######################################
      echo "-> Start of echo $N | $TRUST_ROOT/bin/lance_test"
      echo "  See $PERF"
      fic_test=`dirname $exec`/.tests_`basename $exec`
      rm -f $fic_test
      echo " " >> $REP_HIST/lance_test.$DATE
      echo "######################################################" >> $REP_HIST/lance_test.$DATE
      echo " " >> $REP_HIST/lance_test.$DATE
      echo $ECHO_OPTS $N | lance_test $exec `dirname $exec` 2>&1 >> $REP_HIST/lance_test.$DATE
      PAR=0
      export PAR
      if [ -f $fic_test ]
      then
         #cat $fic_test".html" | grep "Mo|" >> $PERF
         cat $fic_test".html" | $TRUST_Awk -F":" '/ucces/ {print "succes "$2}' >> $PERF
	 grep -A 5000 unsuccess $fic_test".html" >> $PERF
      fi
      # On fait l'executable share libs
      # CC: 16/02/2015 => Pourquoi fait-on ca ici et pas lors de la compilation plus haut ?
      #(cd $TRUST_ROOT/src/MAIN;make)
      (
      OPT=""
      [ $exec = "$exec_debug" ] && OPT=_
      [ $exec = "$exec_semi_opt" ] && OPT=_semi_opt_
      OPT=${OPT%_} # <=> OPT=${OPT::-1}
      if [ $type = Statique ]
      then
	 echo "Call to make with COMPIL_DYN=OFF on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
	 cmake . -DCOMPIL_DYN=OFF
      elif [ $type = Dynamique ]  
      then
	 echo "Call to make with COMPIL_DYN=ON  on $TRUST_ROOT/MonoDir_mpi$OPT/src"
         cd $TRUST_ROOT/MonoDir_mpi$OPT/src
         cmake . -DCOMPIL_DYN=ON
      fi 
      tmp=`mktemp_`
      make 1>>$tmp 2>&1
      tail -n2 $tmp
      rm -f $tmp
      )
   fi
   # Suite au test `$exec 2>&1 | grep TRUST`
   rm -f convert_jdd hierarchie.dump TRUST.log
done
echo " "
echo "<--- End at "`date '+%H:%M:%S'`

#################################################
# Verification de la portabilite des composants #
#################################################
cd $TRUST_ROOT
echo " "
echo "#################"
echo "# On components #"
echo "#################"
echo "---> Begin at "`date '+%H:%M:%S'`
vue="git/Livraison"
echo "Call check_components for $TRUST_VERSION version from `pwd`"
check_components $vue
echo "<--- End at "`date '+%H:%M:%S'`
echo " "
echo "------------------------------------------------------"
echo " "
echo "#####################################"
echo "# Validate and save the new version #"
echo "#####################################"
cd $TRUST_ROOT
echo " "
echo "###################################"
echo "# Create the matrix of validation #"
echo "###################################"
echo "---> Begin at "`date '+%H:%M:%S'`
(
matrice_validation=0 # Non actualise
# Changement 164, on cree la matrice de validation le samedi uniquement
# CC: 16/02/2015 => On ne passe jamais car via crontab, lance_test_nuit est lance du lundi au vendredi (pas le samedi !)
# sauf si cette etape se passe le vendredi apres minuit
# MAIS dans tous les cas matrice_validation ne verifie pas ==1 !!!
if [ "$matrice_validation" = 1 ] && [ "`date '+%u'`" = 6 ]
then
   cd $TRUST_ROOT/doc/Validation
   echo "-> Start of "$TRUST_ROOT"/doc/Validation/Matrice.sh"
   echo "  See `pwd`/Matrice_Validation.pdf"
   ./Matrice.sh -no_verbose # Utiliser l'option -no_verbose permet de conserve une trace dans le fichier Matrice.log du lance_test_modifie
   if [ -f Matrice.pdf ] && [ "`diff Matrice.pdf Matrice_Validation.pdf`" != "" ]
   then
      CHECKOUT Matrice_Validation.pdf 1>/dev/null 2>&1
      mv -f Matrice.pdf Matrice_Validation.pdf
   fi
   cd - 1>/dev/null 2>&1
else
   echo "NOT executed"
fi
) &
echo "<--- End at "`date '+%H:%M:%S'`

echo " "
echo "#####################################"
echo "# Use and execute cpplint.py script #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
# le samedi uniquement
if [ "`date '+%u'`" = 6 ]
then
   cd $TRUST_ROOT
   echo "Call to $TRUST_ROOT/bin/KSH/cpplint.py"
   echo "from `pwd`"
   cpplint_log=$REP_NUIT"/cpplint_$HOST.log"
   echo "  See $cpplint_log"
   echo "TRUST script on $HOST the `date` ...">$cpplint_log
   filter="--filter=-whitespace,-legal/copyright,-build/header_guard,-runtime/references,-readability/casting,\
-build/include_what_you_use,-runtime/sizeof,-runtime/explicit,-runtime/printf,-runtime/int,\
-readability/function,-readability/braces,-readability/streams,-readability/multiline_comment"   
   echo "====================================
Running cpplint by filtering with --filter=$filter
====================================" >> $cpplint_log
   python $TRUST_ROOT/bin/KSH/cpplint.py $filter src/*/*.cpp src/*/*/*.cpp src/*/*/*/*.cpp src/*/*/*/*/*.cpp include/*.h 2>&1 | grep -v "Done processing" >> $cpplint_log
   tail -n1 $cpplint_log
   cat $cpplint_log | mail_ -s\"[lance_test_nuit] Google rules with cpplint on TRUST $new\" $TRUST_MAIL $TRUST_PROJECT_LEADER
else
   echo "NOT executed"
fi
echo "<--- End at "`date '+%H:%M:%S'`

echo " "
echo "######################"
echo "# Build the packages #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S'`
GRAVAGE=$WORKDIR/A_GRAVER_CD_TRUST
echo "Deleting of _build_ packages in $GRAVAGE"
ls -f $GRAVAGE/*_build_*
rm -f $GRAVAGE/*_build_*
v=${Version#Version}
version_arch=TRUST-$v".tar"
keys="keys"$v
package_log=$REP_NUIT"/package_$HOST.log"
# Dans le paquet officiel, on ne met pas les tests de validation car cela prend trop de place
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/mise_a_jour_TRUST_tar -without_test_validation"
echo "  See $package_log"
echo "TRUST script on $HOST the `date` ...">$package_log
echo>>$package_log
mise_a_jour_TRUST_tar -without_test_validation 1>>$package_log
grep "Creation of" $package_log
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/cree_Version_TRUST $v"
echo "  See $package_log"
echo $ECHO_OPTS $v"\n" | cree_Version_TRUST 1>>$package_log
tail -n1 $package_log
echo " "
echo "Move $version_arch packages to $GRAVAGE"
mv $TRUST_ROOT/$version_arch $GRAVAGE/.
[ -f $TRUST_ROOT/$keys ] && mv $TRUST_ROOT/$keys $GRAVAGE/.
ls $GRAVAGE/$version_arch
ls $GRAVAGE/$keys
cd $TRUST_ROOT
echo "<--- End at "`date '+%H:%M:%S'`
#
#
#
####################
# Release criteria #
####################
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/RELEASE_NOTES ] && $TRUST_Awk '/Release notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/RELEASE_NOTES >> $MESSAGES_NUIT
[ -f $TRUST_ROOT/DEVELOPER_NOTES ] && $TRUST_Awk '/Developer notes/ {i++} (i==1) {print $0}' $TRUST_ROOT/DEVELOPER_NOTES >> $MESSAGES_NUIT
echo $ECHO_OPTS "User TRUST      diffusion list http://saxifrage:3500/wws/info/trio_u_annonces" 	>> $MESSAGES_NUIT
echo $ECHO_OPTS "Developer TRUST diffusion list http://saxifrage:3500/wws/info/trio_u_dev" 		>> $MESSAGES_NUIT
echo $ECHO_OPTS "User MC2         diffusion list http://saxifrage:3500/wws/info/mc2_annonces" 		>> $MESSAGES_NUIT
echo $ECHO_OPTS "Kernel             mailing list http://saxifrage:3500/wws/info/trio_u_kernel" 		>> $MESSAGES_NUIT
echo $ECHO_OPTS "Post processing    mailing list http://saxifrage:3500/wws/info/trio_u_post_traitement" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Front Tracking     mailing list http://saxifrage:3500/wws/info/trio_u_front_tracking" 	>> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" 	>> $MESSAGES_NUIT
echo $ECHO_OPTS "TRUST ftp site:             ftp://$TRUST_FTP/$PUBLIC/index.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest TRUST binary:        ftp://$TRUST_FTP/$SECRET/exec/linux/TRUST_mpi_opt"_"$new"_build_"$DATE.gz" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest User's manual:        ftp://$TRUST_FTP/$SECRET/doc/User_Manual_TRUST.pdf" >> $MESSAGES_NUIT
echo $ECHO_OPTS "Latest list of builds:       ftp://$TRUST_FTP/$SECRET/NUIT/NUIT.html" >> $MESSAGES_NUIT
echo $ECHO_OPTS "---------------------------------------------------------------------------------" 	>> $MESSAGES_NUIT
echo "Binaries of TRUST $new version are available here:" >> $MESSAGES_NUIT
for machine in `liste_machines updated`
do 
   ssh_ $machine -n 'echo -e "'$machine:'\n\c";ls ${WORKDIR:-$HOME}/Version_test_*/TRUST/exec/TRUST_mpi_opt 2>/dev/null || echo' 2>/dev/null
done >> $MESSAGES_NUIT
echo "Older binaries (> v1.6.6) are available here: ftp://$TRUST_FTP/$PUBLIC/" >> $MESSAGES_NUIT
echo "Older binaries (< v1.6.6) are available here: file:///net/dibona/users/dibona/triou/version" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
##########################################################
# On checkine dans la vue si criteres suivants respectes :
##########################################################
echo "Release criteria of the $new version:" >> $MESSAGES_NUIT

criteres_remplis=0
total_criteres=0

######################
# Tests d'installation
######################
echo " "
echo "############################################"
echo "# Test the installation to remote machines #"
echo "############################################"
echo "---> Begin at "`date '+%H:%M:%S'`
version_arch=TRUST-$TRUST_VERSION".tar"
installation=0
remote1="-remote "`liste_machines "\-remote_install_TRUST_with_source" 		| head -1 | $TRUST_Awk -F. '{print $1}'`
remote2="-remote "`liste_machines "\-remote_install_TRUST_kernel_only" 		| head -1 | $TRUST_Awk -F. '{print $1}'`
remote3="-remote "`liste_machines "\-remote_install_TRUST_without_source" 		| head -1 | $TRUST_Awk -F. '{print $1}'`
remote1_log=$REP_NUIT"/simule_install_TRUST_with_source_"`echo ${remote1##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote1_log
echo>>$remote1_log
remote2_log=$REP_NUIT"/simule_install_TRUST_kernel_only_"`echo ${remote2##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote2_log
echo>>$remote2_log
remote3_log=$REP_NUIT"/simule_install_TRUST_without_source_"`echo ${remote3##* }`".log"
echo "TRUST script on $HOST the `date` ...">$remote3_log
echo>>$remote3_log
cd $GRAVAGE
echo "Call to $TRUST_ROOT/bin/admin/simule_install_TRUST $version_arch $remote1"
echo "  See $remote1_log"
echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote2 -kernel_only"
echo "  See $remote2_log"
echo "Call to $TRUST_ROOT/bin/admin/extract_Version_TRUST $version_arch -install $remote3 -without_source"
echo "  See $remote3_log"
echo " "
# Test d'une extraction/installation d'une version avec les sources
(
simule_install_TRUST ./$version_arch $remote1 					1>>$remote1_log 2>&1 			
if [ $? != 0 ]
then
   echo "Installation KO -with_source on $remote1"
   cat $remote1_log | mail_ -s\"[lance_test_nuit] Remote install with source failed on ${remote1##* }\" $TRUST_MAIL
   cp $remote1_log $TRUST_ROOT/simule_install_TRUST.log
else
   echo "Installation OK -with_source on $remote1"
fi
) &
installation_id1=$!
# Test d'une extraction/installation d'une version kernel
(
extract_Version_TRUST ./$version_arch -install $remote2 -kernel_only 		1>$remote2_log 2>&1
if [ $? != 0 ]
then
   echo "Installation KO -kernel_only on $remote2"
   cat $remote2_log | mail_ -s\"[lance_test_nuit] Remote install kernel only failed on ${remote2##* }\" $TRUST_MAIL
   cp $remote2_log $TRUST_ROOT/simule_install_TRUST_kernel_only.log
else
   echo "Installation OK -kernel_only on $remote2"
fi
) &
installation_id2=$!
# Test d'une extraction/installation d'une version sans les sources
(
extract_Version_TRUST ./$version_arch -install $remote3 -without_source 	1>$remote3_log 2>&1
if [ $? != 0 ]
then
   echo "Installation KO -without_source on $remote3"
   cat $remote3_log | mail_ -s\"[lance_test_nuit] Remote install without source failed on ${remote3##* }\" $TRUST_MAIL
   cp $remote3_log $TRUST_ROOT/simule_install_TRUST_without_source.log
else
   echo "Installation OK -without_source on $remote3"
fi
) &
installation_id3=$!
# On attend la fin des installations lancees en parallele
wait $installation_id1 $installation_id2 $installation_id3 1>/dev/null 2>&1
# S'il n'y a pas de logs, c'est que les installations ont toutes reussies
if [ "`ls $TRUST_ROOT/simule_install_TRUST*.log 2>/dev/null`" = "" ]
then
   installation=1
fi
rm -f $TRUST_ROOT/simule_install_TRUST*.log
################################
# Test de la taille du DVD grave
################################
echo " "
echo "Test the size of the $version_arch package if it can be written to a DVD"
limite_Mo=2000
if [ "`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{if ($5>limite_Mo*1000000) print "KO"}'`" = KO ]
then
   msg="The package $version_arch on $GRAVAGE is too large (`ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{print $5/1000000}'`>"$limite_Mo"Mo) to be written to a DVD."
   tmp=`mktemp_`
   echo $msg > $tmp
   echo "More large files (>2Mo) in each VOB:" >> $tmp
   (
   cd $TRUST_ROOT
   for contenu in *gz.files
   do
      VOB=${contenu%.tar.gz.files}
      cd $TRUST_ROOT/../$VOB
      echo $VOB >> $tmp
      for file in `cat $TRUST_ROOT/$contenu`
      do
         [ -f $file ] && echo $file
      done | xargs ls -l | awk '{if ($5>2000000) print $5" "$NF}' | sort -nr >> $tmp
      cd - 1>/dev/null 2>&1
   done
   )
   cat $tmp | mail_ -s\"[lance_test_nuit] Problem of $version_arch package size that is too large to be delivered.\" $TRUST_MAIL
   cat $tmp
   rm -f $tmp
   installation=0
   echo "  Size `ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{print $5/1000000}'` > "$limite_Mo"Mo KO"
else
   echo "  Size `ls -lart $version_arch | $TRUST_Awk -v limite_Mo=$limite_Mo '{print $5/1000000}'` < "$limite_Mo"Mo OK"
fi
cd - 1>/dev/null 2>&1
echo " "
if [ "$installation" = 1 ]
then
   echo "Release criterion: Installation OK"
else
   echo "Release criterion: Installation KO"
fi
force_installation=~/force_installation && [ -f $force_installation ] && installation=1 && rm -f $force_installation
echo "$installation  Installation $installation (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$installation
echo "<--- End at "`date '+%H:%M:%S'`

#####################################################################
# Attente jusqu'a pour attendre le retour des compilations eloignees:
#####################################################################
while [ `date '+%H'` -lt 6 ] || [ `date '+%H'` -gt 21 ]
do
   sleep 30
done

##########################################################
# Recupere les executables et divers fichiers sur machines
##########################################################
echo " "
echo "#####################################################"
echo "# Receive from remote machines and copy on ftp site #"
echo "#####################################################"
echo "---> Begin at "`date '+%H:%M:%S'`
cd $TRUST_ROOT
export binaire=1
recupere_log=$REP_NUIT/recupere_TRUST_arch_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/recupere_TRUST_arch"
echo "  See $recupere_log"
echo "TRUST script on $HOST the `date` ...">$recupere_log
echo>>$recupere_log
recupere_TRUST_arch 1>>$recupere_log 2>&1
grep KO $recupere_log
grep -i portage $recupere_log
echo "  Creation of $REP_NUIT/NUIT.html"
ls -la $REP_NUIT"/NUIT.html"
# Deplace le log des etudes si script termine
if [ -f $ETUDES/run_Etudes.log ]
then
  mv -f $ETUDES/run_*.log $REP_NUIT/.
fi
cd $TRUST_ROOT

for file in `ls $REP_NUIT/install_patch_*.log`
do
   echo " "
   echo "Analysis of $file file"
   head -n4 $file | tail -n1
   grep -i error $file
   grep KO $file
done

for file in `ls $REP_NUIT/lance_test_*.log`
do
   echo " "
   echo "Analysis of $file file"
   fic_test=`grep "Complete results into the file" -A 1 $file | tail -n 1`
   grep "Error:" $fic_test
   grep "Successful tests cases" $fic_test
done

echo "<--- End at "`date '+%H:%M:%S'`

##################
# Stabilite TRUST
##################
echo " "
echo "######################"
echo "# Test the stability #"
echo "######################"
echo "---> Begin at "`date '+%H:%M:%S'`
fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM
echo "Analysis of "$fic_test" file"
grep "Successful tests cases" $fic_test
echo " "
fic_test=$TRUST_ROOT"/exec/.tests_TRUST"$COMM"_semi_opt"
echo "Analysis of "$fic_test" file"
grep "Successful tests cases" $fic_test
echo " "
if [ -f $fic_test ]
then
   stabilite=`$TRUST_Awk -F':' 'BEGIN {print "scale=3\n"} /Successful tests cases/ {print $2}' $fic_test | bc -l | sort -n | head -1`
else
   stabilite="0.000"
fi
if [ "$stabilite" = "1.000" ]
then
   echo "Release criterion: Stability OK"
else
   echo "Release criterion: Stability KO"
fi
force_stabilite=~/force_stabilite && [ -f $force_stabilite ] && stabilite="1.000" && rm -f $force_stabilite
echo `if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`"  Stability $stabilite (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$stabilite" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S'`

####################
# Portabilite TRUST
####################
echo " "
echo "###############################"
echo "# Test the TRUST portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $recupere_log file"
grep "step TRUST" $recupere_log
echo "Analysis of $TRUST_ROOT/NUIT/NUIT.html file"
grep "TRUST portability" $TRUST_ROOT/NUIT/NUIT.html
echo " "
portabilite_trio=`$TRUST_Awk '/TRUST portability/ {print $1}' $TRUST_ROOT/NUIT/NUIT.html`
portabilite=0 && [ "`grep "Portable version" $TRUST_ROOT/NUIT/NUIT.html`" != "" ] && portabilite=1
if [ "$portabilite" = 1 ]
then
   echo "Release criterion: TRUST  OK"
else
   echo "Release criterion: TRUST  KO"
fi
force_portabilite=~/force_portabilite && [ -f $force_portabilite ] && portabilite=1 && rm -f $force_portabilite
echo "$portabilite  Portability $portabilite_trio (>.99)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite
echo "<--- End at "`date '+%H:%M:%S'`

###################
# Test d'un atelier
###################
echo " "
echo "######################################"
echo "# Test the compilation of a workshop #"
echo "######################################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $recupere_log file"
grep "step workshop" $recupere_log
echo "Analysis of $TRUST_ROOT/NUIT/NUIT.html file"
grep "TRUST workshop compilation" $TRUST_ROOT/NUIT/NUIT.html
make_atelier=`$TRUST_Awk '/workshop compilation/ && /TRUST/ {print $1}' $TRUST_ROOT/NUIT/NUIT.html`
echo " "
if [ "$make_atelier" = "1.000" ]
then
   echo "Release criterion: Workshop OK"
else
   echo "Release criterion: Workshop KO"
fi
force_make_atelier=~/force_make_atelier && [ -f $force_make_atelier ] && make_atelier="1.000" && rm -f $force_make_atelier
echo `if [ "$make_atelier" = "1.000" ]; then echo 1;else echo 0;fi`"  Workshop $make_atelier (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$make_atelier" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S'`

#####################
# Portabilite Xprepro
#####################
echo " "
echo "################################"
echo "# Test the Xprepro portability #"
echo "################################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $recupere_log file"
grep "step Xprepro" $recupere_log
echo "Analysis of $TRUST_ROOT/NUIT/NUIT.html file"
grep "Xprepro portability" $TRUST_ROOT/NUIT/NUIT.html
echo " "
Xprepro=`$TRUST_Awk '/Xprepro portability with TRUST/ {print $1}' $TRUST_ROOT/NUIT/NUIT.html`
portabilite_Xprepro=`echo $Xprepro | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
if [ "$portabilite_Xprepro" = 1 ]
then
   echo "Release criterion: Xprepro OK"
else
   echo "Release criterion: Xprepro KO"
fi
force_portabilite_Xprepro=~/force_portabilite_Xprepro && [ -f $force_portabilite_Xprepro ] && portabilite_Xprepro=1 && rm -f $force_portabilite_Xprepro
echo "$portabilite_Xprepro  Xprepro $Xprepro (>=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$portabilite_Xprepro
echo "<--- End at "`date '+%H:%M:%S'`

#######################
# Portabilite de BALTIK
#######################
echo " "
echo "###############################"
echo "# Test the Baltik portability #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $recupere_log file"
grep "step Baltik" $recupere_log
echo "Analysis of $TRUST_ROOT/NUIT/NUIT.html file"
grep "Baltik portability" $TRUST_ROOT/NUIT/NUIT.html
echo " "
portabilite_baltik=`$TRUST_Awk '/Baltik portability/ && /TRUST/ {print $1}' $TRUST_ROOT/NUIT/NUIT.html`
if [ "$portabilite_baltik" = "1.000" ]
then
   echo "Release criterion: Baltik  OK"
else
   echo "Release criterion: Baltik  KO"
fi
force_portabilite_baltik=~/force_portabilite_baltik && [ -f $force_portabilite_baltik ] && portabilite_baltik="1.000" && rm -f $force_portabilite_baltik
echo `if [ "$portabilite_baltik" = "1.000" ]; then echo 1;else echo 0;fi`"  Baltik $portabilite_baltik (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$portabilite_baltik" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S'`

################################
# Test des assert de compilation
################################
echo " "
echo "###############################"
echo "# Test the compilation assert #"
echo "###############################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $recupere_log file"
grep "step assert" $recupere_log
echo "Analysis of $TRUST_ROOT/NUIT/NUIT.html file"
grep "Compilation assert test" $TRUST_ROOT/NUIT/NUIT.html
test_assert=`$TRUST_Awk '/Compilation assert/ {print $1}' $TRUST_ROOT/NUIT/NUIT.html`
echo " "
if [ "$test_assert" = "1.000" ]
then
   echo "Release criterion: Assert OK"
else
   echo "Release criterion: Assert KO"
fi
force_test_assert=~/force_test_assert && [ -f $force_test_assert ] && test_assert="1.000" && rm -f $force_test_assert
echo `if [ "$test_assert" = "1.000" ]; then echo 1;else echo 0;fi`"  Assert $test_assert (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+`if [ "$test_assert" = "1.000" ]; then echo 1;else echo 0;fi`
echo "<--- End at "`date '+%H:%M:%S'`

############################
# Disponibilite des binaires
############################
echo " "
echo "######################################"
echo "# Test the disponibility of binaries #"
echo "######################################"
echo "---> Begin at "`date '+%H:%M:%S'`
nb_binaires=0
disponibilite_binaires=0
echo "Analysis of $WORKDIR/PORTAGE_$new directory"
binaires=`ls $WORKDIR/PORTAGE_$new/*/TRUST/exec/TRUST*opt* 2>/dev/null`
[ "$binaires" = "" ] && echo | mail_ -s\"[lance_test_nuit] No binary created under $WORKDIR/PORTAGE_$new/*/TRUST/exec\" $TRUST_MAIL
for binaire in $binaires
do
   let nb_binaires=$nb_binaires+1
   cd $TRUST_TMP
   rm -f nul.data
   touch nul.data
   echo $ECHO_OPTS "  Test of binary $binaire \c"
   $binaire nul 1>binaire.out 2>&1
   if [ $? != 0 ]
   then
      echo "KO"
      cat binaire.out | mail_ -s \"[lance_test_nuit] Binary $binaire KO\" $TRUST_MAIL
   else
      let disponibilite_binaires=$disponibilite_binaires+1
      echo "OK"
   fi
   cd - 1>/dev/null 2>&1
done
[ "$nb_binaires" != 0 ] && disponibilite_binaires=`echo $disponibilite_binaires | $TRUST_Awk -v n=$nb_binaires '{print "scale=3\n"$1"/"n}' | bc -l`
disponibilite_binaires=`echo $disponibilite_binaires | $TRUST_Awk '{if ($1>=1) print 1;else print 0}'`
echo " "
if [ "$disponibilite_binaires" = 1 ]
then
   echo "Release criterion: Binaries OK"
else
   echo "Release criterion: Binaries KO"
fi
force_disponibilite_binaires=~/force_disponibilite_binaires && [ -f $force_disponibilite_binaires ] && disponibilite_binaires=1 && rm -f $force_disponibilite_binaires
echo "$disponibilite_binaires  Binairies $disponibilite_binaires (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$disponibilite_binaires
echo "<--- End at "`date '+%H:%M:%S'`

############
# Test XData
############
echo " "
echo "##################################"
echo "# Verify the validation of XData #"
echo "##################################"
echo "---> Begin at "`date '+%H:%M:%S'`
validation_xdata=""
machines=`liste_machines "\-xdata" | $TRUST_Awk -F. '{print $1}'`
echo "Validation by -xdata on $machines"
# Si une machine a XData qui fonctionne c'est OK
for machine in $machines
do
   check_xdata_log=$REP_NUIT"/check_xdata_"$machine".log"
   echo "  See $check_xdata_log"
   rm -f $check_xdata_log
   scp triou@$machine:~/Version_test_$machine/TRUST/Outils/TRIOXDATA/check_xdata.log $check_xdata_log
   scp_error=$?
   if [ $scp_error != 0 ]
   then
      echo | mail_ -s\"[lance_test_nuit] Error when receiving XData log from $machine. Check if not finished.\" $TRUST_MAIL #$TRUST_PROJECT_LEADER
   else
      grep 'XDATA=' $check_xdata_log
   fi
   rm -f $scp_error
   if [ "`grep 'XDATA=OK' $check_xdata_log 2>/dev/null`" != "" ]
   then
      validation_xdata=1
   else
      [ "$validation_xdata" = "" ] && validation_xdata=0
      [ -f $check_xdata_log ] && cat $check_xdata_log | mail_ -s \"[lance_test_nuit] Check XData on $machine KO\" $TRUST_PROJECT_LEADER $TRUST_MAIL
   fi
done
echo " "
if [ "$validation_xdata" = 1 ]
then
   echo "Release criterion: XData OK"
else
   echo "Release criterion: XData KO"
fi
force_validation_xdata=~/force_validation_xdata && [ -f $force_validation_xdata ] && validation_xdata=1 && rm -f $force_validation_xdata
echo "$validation_xdata  XData $validation_xdata (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_xdata
echo "<--- End at "`date '+%H:%M:%S'`

##########################
# Verification des modules
##########################
echo " "
echo "####################################"
echo "# Verify the validation of Modules #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
activation_verification_modules=0 # Non actualise
if [ "$activation_verification_modules" = 1 ]
then
   cd $TRUST_ROOT/Validation/Modules
   # Lancement d'un cas test par module:
   echo "Call to $TRUST_ROOT/Validation/Modules/Test.sh"
   ./Test.sh
   if [ $? != 0 ]
   then
      echo "  Error in one case per module"
      echo " "
      echo "Release criterion: Modules KO"
   else 
      echo "  Lauching of one case per module OK"
      # Recuperation de tous les cas tests par module
      modules=`cd $TRUST_ROOT/Validation/Modules;ls */cree_liste_cas | $TRUST_Awk -F/ '{print $1}'`
      echo " "
      if [ "${#modules}" = 0 ]
      then
         ok=0
         nb=-1
	 echo "Zero module in $TRUST_ROOT/Validation/Modules directory"
      else
	 echo "Modules in $TRUST_ROOT/Validation/Modules directory:"
         echo modules
         ok=0
         nb=0
         for module in $modules
         do
	    echo " "
	    echo "Verification of $TRUST_ROOT/Validation/Modules/$module"
	    cd $TRUST_ROOT/Validation/Modules/$module
	    rm -f $module.log
	    machine=`liste_machines "\-verification_module_$module"`
	    if [ "$machine" != "" ]
	    then
	       let nb=$nb+1
	       hostname=`echo $machine | $TRUST_Awk -F. '{print $1}'`
	       module_log=$REP_NUIT"/Modules_"$module"_"$hostname".log"
	       echo "  Receive tests of $module module from $hostname"
	       log=`awk -v adr=$machine '($2==adr) {print $4}' ~/.netrc | head -1`
	       scp $log@$machine:~/Version_test_$hostname/TRUST/Validation/Modules/$module/$module.log . 2>/dev/null
	       scp $log@$machine:~/Version_test_$hostname/TRUST/Validation/Modules/$module/compare_resultat.log . 2>/dev/null
	       # On efface les rapports precedants
	       rm -f .tests_TRUST_*
	       scp $log@$machine:~/Version_test_$hostname/TRUST/Validation/Modules/$module/.tests_TRUST_* . 2>/dev/null
	       if [ ! -f $module.log ]
	       then
                  echo | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host no made or no recovered.\" $TRUST_MAIL 
	       else
	          if [ "`grep $module=OK $module.log 2>/dev/null`" != "" ]
	          then
        	     let ok=$ok+1
	          else    
		     if [ "`grep $module=KO $module.log 2>/dev/null`" != "" ]
		     then
        	        [ ! -f compare_resultat.log ] && ../compare_resultat .tests_TRUST_mpi_*
        	        cat compare_resultat.log | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host KO\" $TRUST_MAIL $TRUST_PROJECT_LEADER
		     else
		        cat .tests_TRUST_mpi_* | mail_ -s\"[lance_test_nuit] Verification of $module module to $machine host not finished\" $TRUST_MAIL #$TRUST_PROJECT_LEADER
		     fi
	          fi
	          # Mise a jour de la reference
	          if [ "`grep 'On change la reference' $module.log`" != "" ]
	          then
        	     echo "  Update reference of $module module"
        	     CHECKOUT res_test_ref 1>/dev/null 2>&1
		     new_rapport=`ls -rt .tests_TRUST_* | grep -v KO | grep -v OK 2>/dev/null | tail -1`
		     [ "$new_rapport" != "" ] && cat $new_rapport > res_test_ref
	          fi
	       fi
	       # Faire une page html regroupant l'ensemble des resultats
	    fi
         done
	 [ $nb -eq 0 ] && nb=-1
      fi
      verification_modules=0 && [ $ok -eq $nb ] && verification_modules=1
      echo " "
      if [ "$verification_modules" = 1 ]
      then
         echo "Release criterion: Modules OK"
      else
         echo "Release criterion: Modules KO"
      fi
      force_verification_modules=~/force_verification_modules && [ -f $force_verification_modules ] && verification_modules=1 && rm -f $force_verification_modules
      echo "$verification_modules  Modules $ok/$nb="`echo "scale=3;$ok/$nb" | bc`" (=1.000)" >> $MESSAGES_NUIT
      let total_criteres=$total_criteres+1
      let criteres_remplis=$criteres_remplis+$verification_modules
   fi
   cd $TRUST_ROOT
else
   echo "NOT executed"
fi
echo "<--- End at "`date '+%H:%M:%S'`

##########
# Valgrind
##########
echo " "
echo "#####################################"
echo "# Verify the validation of Valgrind #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
# Recuperer le ANA.log sur les machines valgrind
cd $TRUST_ROOT/Validation/Valgrind
rm -f ANA_*.log casmem_* caserr_*
machines=`liste_machines "\-valgrind" | $TRUST_Awk -F. '{print $1}'`
if [ "${#machines}" = 0 ]
then
   valgrind=0
else
   valgrind=1
   echo "Validation by -valgrind on"
   echo $machines
   echo " "
fi
for machine in $machines
do
   echo "Verification of $TRUST_ROOT/Validation/Valgrind/ANA_$machine.log"
   scp triou@$machine:~/Version_test_$machine/TRUST/Validation/Valgrind/ANA.log ANA_$machine.log
   scp_error=$?
   if [ $scp_error != 0 ]
   then
      echo | mail_ -s\"[lance_test_nuit] Error when receiving Valgrind log from $machine. Check if not finished.\" $TRUST_MAIL #$TRUST_PROJECT_LEADER
   fi
   rm -f $scp_error
   sleep 1
   if [ ! -f ANA_$machine.log ]
   then
      # echo | mail_ -s \"[lance_test_nuit] Valgrind not finished on $machine\" $TRUST_PROJECT_LEADER $TRUST_MAIL  
      echo "  valgrind not finished"
      valgrind=0
   else
      scp triou@$machine:~/Version_test_$machine/TRUST/Validation/Valgrind/casmem casmem_$machine
      cat ANA_$machine.log 2>/dev/null | $TRUST_Awk -F: '/ errors from /{gsub("\\.val","",$2);print $2}' > caserr_$machine
      valgrind_max=0
      valgrind_err=`cat caserr_$machine 2>/dev/null | wc -l`
      # On supprime les cas de casmem qui se retrouvent dans liste (cas qui se sont arretes)
      grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste casmem_$machine > cas
      valgrind_leak=`cat cas 2>/dev/null | wc -l`
      rm -f cas
      let valgrind_err=$valgrind_err+$valgrind_leak
      echo "  valgrind $valgrind_err errors including $valgrind_leak memory leak ($valgrind_err<=$valgrind_max)"  
      [ ! "$valgrind_err" = 0 ] && echo "    See `pwd`/caserr_$machine" && cat caserr_$machine
      [ ! "$valgrind_leak" = 0 ] && echo "    See `pwd`/casmem_$machine" && cat casmem_$machine
      if [ ${#valgrind_err} = 0 ] || [ $valgrind_err -gt $valgrind_max ]
      then
         valgrind=0 
	 # Envoi d'un mail pour prevenir immediatement
	 cat caserr_$machine casmem_$machine >> $TRUST_TMP/cas
	 if [ -s $TRUST_TMP/cas ]
	 then
	    log_filtre=`mktemp_`
	    grep -v -f $TRUST_ROOT/exec/tests_TRUST$COMM"_semi_opt"/liste ANA_$machine.log 1>$log_filtre 2>&1
	    echo "-----------" >>$log_filtre
	    cat $TRUST_TMP/cas >>$log_filtre
	    [ -s $log_filtre ] && cat $log_filtre | mail_ -s \"[lance_test_nuit] `$TRUST_ROOT/exec/valgrind/bin/valgrind --version` detects errors on $machine host!!!\" $TRUST_PROJECT_LEADER $TRUST_MAIL
            rm -f $log_filtre
	 fi
      fi
   fi
done
echo " "
if [ "$valgrind" = 1 ]
then
   echo "Release criterion: Valgrind OK"
else
   echo "Release criterion: Valgrind KO"
fi
force_valgrind=~/force_valgrind && [ -f $force_valgrind ] && valgrind=1 && rm -f $force_valgrind
echo "$valgrind  Valgrind $valgrind (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$valgrind
echo "<--- End at "`date '+%H:%M:%S'`
#
#
#
echo " "
echo "############################"
echo "# Verify the code coverage #"
echo "############################"
echo "---> Begin at "`date '+%H:%M:%S'`
#############
# GCOV/LCOV #
#############
repertoire_gcov=$TRUST_ROOT/MonoDir$COMM/src
machines=`liste_machines "\-all" "\-gcov"`
echo "Validation by -gcov on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by gcov!!!" 
   echo "Warning: No host -all -gcov in liste.machines! No coverage by gcov." | mail_ -s\"[lance_test_nuit] GCOV/LCOV: NO coverage!!!\" $TRUST_MAIL
fi
for machine_gcov in $machines # Compilation avec -gcov et passage de tous les cas tests
do
   hostname=`echo $machine_gcov | $TRUST_Awk -F. '{print $1}'` 
   echo "  Recovery from $hostname"
   echo "    See $REP_NUIT/analyse_couverture_$hostname.log"
   scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/analyse_couverture.log $REP_NUIT/analyse_couverture_$hostname.log
   scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/monana_out $REP_NUIT/monana_out_$hostname.log
   scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_out $REP_NUIT/gcov_out_$hostname.log
   scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/gcov_err $REP_NUIT/gcov_err_$hostname.log
   # Copie cpp.gcov.tar.gz 
   file=cpp.gcov.tar.gz  
   echo "    Copy $file to $TRUST_ROOT/doc/Coverage/"
   rm -f $TRUST_TMP/$file
   scp triou@$machine_gcov:~/Version_test_$hostname/TRUST/doc/Coverage/$file $TRUST_TMP/$file
   if [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
   then
      echo "    => updated"
      CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1
      mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file
   else
      echo "    => NOT updated"
   fi
   rm -f $TRUST_TMP/$file
   ls -la $TRUST_ROOT"/doc/Coverage/"$file
   # Copie apres menage des fichiers .gcda et .gcno pour pouvoir utiliser tggcov_ plus loin
   #echo "    Copy *.gcda and *.gcno files to $repertoire_gcov"
   #for suffixe in gcda gcno
   #do
   #   find $repertoire_gcov -name '*'.$suffixe | xargs rm -f
   #   #scp triou@$machine_gcov:$WORKDIR/Version_test_$hostname/TRUST/MonoDir$COMM"_gcov"/src/[A-N]*.$suffixe $repertoire_gcov/.
   #   #scp triou@$machine_gcov:$WORKDIR/Version_test_$hostname/TRUST/MonoDir$COMM"_gcov"/src/[N-Z]*.$suffixe $repertoire_gcov/.
   #   #scp triou@$machine_gcov:$WORKDIR/Version_test_$hostname/TRUST/MonoDir$COMM"_gcov"/src/[a-z]*.$suffixe $repertoire_gcov/.
   #   scp triou@$machine_gcov:$WORKDIR/.tmp_TRUST_$hostname/tests/GCDA/ana/*.$suffixe $repertoire_gcov/. 1>/dev/null 2>&1
   #   find $repertoire_gcov -name '*'.$suffixe | wc -l
   #done
   # Copie lcov (genere sur la machine car compilateur et gcov doivent matcher)
   #echo "    Copy html directory to $TRUST_ROOT/doc/Coverage/lcov"
   #rm -r -f $TRUST_ROOT/doc/Coverage/lcov/html
   #mkdir $TRUST_ROOT/doc/Coverage/lcov/html
   #scp -r triou@$machine_gcov:$WORKDIR/Version_test_$hostname/TRUST/doc/Coverage/lcov/html $TRUST_ROOT/doc/Coverage/lcov
   #ls -l $TRUST_ROOT/doc/Coverage/lcov/ | grep html
done
###########
# PROFILE #
###########
# Recuperer des informations de couverture du code (ce n'est pas encore un critere de livraison)
machines=`liste_machines "\-all" "\-prof"`
echo " "
echo "Validation by -prof on $machines"
if [ "$machines" = "" ]
then
   echo "  No coverage by prof!!!" 
   echo "Warning: No host -all -prof in liste.machines! No coverage by prof." | mail_ -s\"[lance_test_nuit] PROFILE: NO coverage!!!\" $TRUST_MAIL
fi
for machine in $machines # Compilation avec -prof et passage de tous les cas tests
do
   cd $TRUST_ROOT/doc/Coverage
   hostname=`echo $machine | $TRUST_Awk -F. '{print $1}'`
   echo "  Recovery from $hostname"
   echo "    See $REP_NUIT/make_Couverture_$hostname.log"
   scp triou@$machine:$WORKDIR/.tmp_TRUST_$hostname/tests/make_Couverture.log $REP_NUIT/make_Couverture_$hostname.log
   error_log=`grep "Problem with the gprof command" $REP_NUIT/make_Couverture_$hostname.log`
   [ ${#error_log} != 0 ] && cat $REP_NUIT/make_Couverture_$hostname.log | mail_ -s\"[lance_test_nuit] Problem with the gprof command on $hostname in make_Couverture\" $TRUST_MAIL
   # Copie file 
   for file in list_methodes.gz list_methodes_non_appelees.gz dico.pkl.gz 
   do
      echo "    Copy $file to $TRUST_ROOT/doc/Coverage/"
      rm -f $TRUST_TMP/$file
      scp triou@$machine:~/Version_test_$hostname/TRUST/doc/Coverage/$file $TRUST_TMP/$file
      if [ -f $TRUST_TMP/$file ] && [ "`diff $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file`" != "" ]
      then
         echo "    => updated"
         CHECKOUT $TRUST_ROOT/doc/Coverage/$file 1>/dev/null 2>&1
	 mv -f $TRUST_TMP/$file $TRUST_ROOT/doc/Coverage/$file
      else
         echo "    => NOT updated"
      fi
      rm -f $TRUST_TMP/$file
      ls -la $TRUST_ROOT"/doc/Coverage/"$file
      # Recuperation du rapport gprof de l'ensemble des cas tests de non regression si cree
      if [ "`grep 'GMON_DIR=""' $TRUST_ROOT/bin/lance_test`" = "" ]
      then
         cpu=all_tests.cpu 
         echo "    Copy $cpu to $TRUST_ROOT/doc/Coverage/"
         #CHECKOUT $cpu
         scp triou@$machine:$WORKDIR/.tmp_TRUST_$hostname/tests/$cpu . 1>/dev/null 2>&1
         #CHECKIN $cpu
         ls -la $TRUST_ROOT"/doc/Coverage/"$cpu
      fi
   done
done
#
##########
# TGGCOV #
##########
# Mise a jour du repertoire doc/Coverage et verification que la couverture est a jour
cd $TRUST_ROOT/doc/Coverage
echo " "
echo "Verification of the coverage in `pwd`:"
# Creation des classes appellees ou non
(
cd $TRUST_ROOT/doc/Coverage
echo "  Call to $TRUST_ROOT/bin/admin/tggcov_ -file"
listing=`mktemp_`
export PYTHONPATH=$PYTHONPATH:$TRUST_ROOT/bin/KSH
python -c "from Couv import nombre_de_cas_par_classe;nombre_de_cas_par_classe()" > $listing
# Classes non testees
for string in `$TRUST_Awk '/ 0 0/ {print $1}' $listing | sort`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      cpp=`basename $path_fichier_cpp`
      tc=`tggcov_ -file $cpp | awk '/File / {print "fichier couvert a "$1"%"}'`
   else
      # Fichier non trouve
      tc=""
   fi
   echo $ECHO_OPTS $string" \tdans \$TRUST_ROOT"${path_fichier_cpp#$TRUST_ROOT/.}" "$tc
done > liste_classes_non_testees
cat liste_classes_non_testees | grep Kernel > liste_classes_non_testees_Kernel
cat liste_classes_non_testees_Kernel | grep " 0.00" > liste_fichiers_Kernel_a_supprimer
for file in liste_classes_non_testees liste_classes_non_testees_Kernel liste_fichiers_Kernel_a_supprimer
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Classes testees
echo "  Call to $TRUST_ROOT/bin/admin/tggcov_ -short -file"
html=liste_classes_testees.html
echo $ECHO_OPTS "<HTML><PRE>Critere\tCouvert\tTests\tClasse" > $html
for string in `$TRUST_Awk '!/ 0 0/ {print $1"|"$2"|"$3}' $listing`
do
   classe=`echo $string | $TRUST_Awk -F'|' '{print $1}'`
   nb_tests=`echo $string | $TRUST_Awk -F'|' '{print $2+$3}'`
   path_fichier_cpp=`ViC $classe cpp -no_vi`
   if [ "$path_fichier_cpp" != "" ]
   then
      fichier_cpp=`basename $path_fichier_cpp`
      taux_couverture=`tggcov_ -short -file $fichier_cpp | $TRUST_Awk '{print $1}'`
      critere=`echo $taux_couverture $nb_tests | $TRUST_Awk '{t=$1;n=$2;c=100*(0.01*t)**n;printf("%7.3f",c)}'`
   else
      fichier_cpp="not_found"
      taux_couverture="?????"
      critere="  0.000"
   fi
   echo $ECHO_OPTS "$critere\t$taux_couverture%\t$nb_tests\t<A HREF=cpp.gcov/$fichier_cpp.gcov>$classe</A>"
done | sort -nr >> $html
echo "</HTML>" >> $html
rm -f $listing
for file in $html
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
)
#
echo "  Analysis of $credoc_log"
grep OK $credoc_log
grep KO $credoc_log
echo "    See $TRUST_ROOT/Outils/TRIOXDATA/pdf_par_xdata.log"
echo "    See $TRUST_TMP/motcles file"
echo "    "`wc -l $TRUST_TMP/motcles | awk '{ print $1 }'`" keywords without test cases!"
[ "`date | $TRUST_Awk '{print $1}'`" = "Fri" ] && [ -f $TRUST_TMP/motcles ] && cat $TRUST_TMP/motcles | mail_ -s \"[lance_test_nuit] Tests coverage credoc\" $TRUST_MAIL $TRUST_PROJECT_LEADER
error_log=`grep 'error Doxygen' $credoc_log`
[ ${#error_log} != 0 ] && mail_ -s\"[check_include] Doxygen: Study of TRUST includes under `pwd`\" $TRUST_MAIL #$TRUST_PROJECT_LEADER
#
##########
# TGGCOV #
##########
# Calcul de la couverture du code par les cas tests
# Attention les .gcda et .gcno doivent etre du meme GCC
cd $repertoire_gcov
#On n'utilise plus ggcov car il faut le meme compilateur pour exploiter les .gcda et .gcno
#couverture_de_code=`tggcov -R all | $TRUST_Awk 'BEGIN {lines="??"} /Summary/ && /src/ {for (i=0;i<7;i++) getline;lines=$1} END {gsub("%","",lines);print lines}'`
echo "  Call to $TRUST_ROOT/bin/admin/tggcov_"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov.log"
$TRUST_ROOT/bin/admin/tggcov_ 1>$REP_NUIT/tggcov.log 2>&1
#tail -n2 $REP_NUIT/tggcov.log
couverture_de_code=`tggcov_ | $TRUST_Awk '/TRUST code/ {print $1}'`
cd - 1>/dev/null 2>&1
couverture_minimale=65.26 #66
coverage=`echo $couverture_de_code | $TRUST_Awk -v m=$couverture_minimale '{if ($1>=m) print 1;else print 0}'`
if [ "$coverage" = 1 ]
then
   echo "    Coverage $couverture_de_code% >= $couverture_minimale% of lines"
else
   echo "    Coverage $couverture_de_code% < $couverture_minimale% of lines"
   cat $REP_NUIT/tggcov.log | mail_ -s\"[lance_test_nuit] Coverage KO with $couverture_de_code% \< $couverture_minimale% of lines tested\" $TRUST_MAIL #$TRUST_PROJECT_LEADER
fi
(
# Creation du rapport html
cd $TRUST_ROOT/doc/Coverage
cd html
echo "  Call to $TRUST_ROOT/bin/admin/tggcov_ -html"
echo "from `pwd`"
echo "    See $REP_NUIT/tggcov_html.log"
$TRUST_ROOT/bin/admin/tggcov_ -html 1>$REP_NUIT/tggcov_html.log 2>&1
tail -n1 $REP_NUIT/tggcov_html.log
echo "    Update html.tgz on $TRUST_ROOT/doc/Coverage"
tar cfz html.tgz *.html
# Mise a jour si different
if [ "`diff -a html.tgz ../html.tgz 2>/dev/null;echo $?`" != 0 ]
then
   echo "    => updated"
   CHECKOUT ../html.tgz 1>/dev/null 2>&1
   mv -f html.tgz ../html.tgz
else
   echo "    => NOT updated"
   rm -f html.tgz
fi
ls -la ../html.tgz
)
cd $TRUST_ROOT/doc/Coverage
echo "  Call to make in $TRUST_ROOT/doc/Coverage"
make clean
make
CPP_GCOV=$TRUST_ROOT/doc/Coverage/html/cpp.gcov
echo "  Verification of $CPP_GCOV"
grep $DATE $CPP_GCOV/MAIN.cpp.gcov
if [ "`grep $DATE $CPP_GCOV/MAIN.cpp.gcov 2>/dev/null`" = "" ]
then
   echo "    KO"
   echo "$CPP_GCOV KO. See on $machine_gcov host with the gcov TRUST binairy: `grep build $CPP_GCOV/MAIN.cpp.gcov`" | mail_ -s\"[lance_test_nuit] Coverage KO on $hostname host\" $TRUST_MAIL
else
   echo "    OK"
fi
for file in list_methodes list_methodes_non_appelees
do
   echo "    "`wc -l $file | awk '{ print $1 }'`" $file"
done
# Nouveau pour 1.6.3: Comparaison de la couverture de code fichier par fichier par rapport a la version precedante (sous $WORKDIR/git/Maintenance)
(
cd $TRUST_ROOT/doc/Coverage/html/cpp.gcov
MAINTENANCE=$WORKDIR/git/Maintenance/TRUST
echo " "
echo "Comparison of code coverage between new and old versions"
echo "from `pwd`"
echo " and $MAINTENANCE/doc/Coverage/html/cpp.gcov"
echo "Call to bin/admin/tggcov_ -short -file *.gcov"
[ ! -d $MAINTENANCE ] && echo "  Verification of test coverage impossible because $MAINTENANCE not exist." #&& coverage=0
log=`mktemp_`
for gcov in *.gcov
do
   if [ -f $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov ]
   then
      file=${gcov%.gcov}
      new_coverage=`tggcov_ -short -file $file`
      old_coverage=`export TRUST_ROOT=$MAINTENANCE;tggcov_ -short -file $file`
      # Regression de la couverture de code (Le nombre de lignes non testees augmente si la couverture est pas nulle)
      couverture=`echo $old | awk '{print $1}'`
      lignes_non_testees_en_plus=`echo $new_coverage $old_coverage | awk '{split($2,new,"/");split($6,old,"/");print (new[2]-new[1])-(old[2]-old[1])}'`
      if [ $lignes_non_testees_en_plus -gt 0 ] && [ $couverture != 0.00 ]
      then
         echo $ECHO_OPTS "$lignes_non_testees_en_plus lines not tested more in $file"
	 # echo "  "sdiff $TRUST_ROOT/doc/Coverage/html/cpp.gcov/$gcov $MAINTENANCE/doc/Coverage/html/cpp.gcov/$gcov
	 # Mise en echec du critere de livraison:
	 #coverage=0
      fi
   fi
done | tee $log
# Pas au point, donc on ne signale rien:
#[ -s $log ] && cat $log | mail_ -s\"[lance_test_nuit] Regression code coverage between `basename $TRUST_ROOT_MASTER` and Maintenance:\" $TRUST_MAIL
rm -f $log
cd - 1>/dev/null 2>&1
)
echo " "
if [ "$coverage" = 1 ]
then
   echo "Release criterion: Coverage OK"
else
   echo "Release criterion: Coverage KO"
fi
echo "$coverage  Coverage $couverture_de_code% (>=$couverture_minimale% of lines)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$coverage
echo "<--- End at "`date '+%H:%M:%S'`
#
#
#
##############
# Parallelisme
##############
echo " "
echo "#####################################"
echo "# Test the stability of parallelism #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
machine=`liste_machines "\-Check_decoupage" | $TRUST_Awk -F. '{print $1}'`
echo "Validation by -Check_decoupage on $machine"
echo "  See $REP_NUIT/Check_decoupage.ksh_$machine.log"
scp triou@$machine:$WORKDIR/.tmp_TRUST_$machine/Check_decoupage/Check_decoupage.ksh.log $REP_NUIT/Check_decoupage.ksh_$machine.log
error_log=`grep "Failure on " $REP_NUIT/Check_decoupage.ksh_$machine.log`
[ ${#error_log} != 0 ] && cat $REP_NUIT/Check_decoupage.ksh_$machine.log | mail_ -s\"[lance_test_nuit] Check_decoupage.ksh on $machine KO\" $TRUST_MAIL
file_log=$REP_NUIT"/PERF_TRUST"$COMM"_opt_linux_"$machine
echo "  Analysis of "$file_log" file"
stabilite_parallelisme=`$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print ok/procs}' $file_log`
$TRUST_Awk '/Calcul sur le cas/ {cas++;procs+=$(NF-1)} /Validite...OK/ {ok++} END {print cas " cases including "ok " OK to "procs" CPUs. Validity = "ok"/"procs" = "ok/procs" %"}' $file_log
parallelism=`echo $stabilite_parallelisme | $TRUST_Awk '{if ($1==1) print 1;else print 0}'`
echo " "
if [ "$parallelism" = 1 ]
then
   echo "Release criterion: Parallelism OK"
else
   echo "Release criterion: Parallelism KO"
   cat $REP_NUIT/Check_decoupage.ksh_$machine.log | mail_ -s\"[lance_test_nuit] KO Check_decoupage script on $machine\" $TRUST_MAIL $TRUST_PROJECT_LEADER
fi
force_check_decoupage=~/force_check_decoupage && [ -f $force_check_decoupage ] && parallelism=1 && rm -f $force_check_decoupage
echo "$parallelism  Parallelism $stabilite_parallelisme (=1.000)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$parallelism
# Desormais le samedi sur pc tma, on met a jour les cas tests
# pour la balise PARALLEL OK
# Dangereux car blocages possibles
#if [ "`date '+%w'`" = 6 ]
#then
#   Check_decoupage.ksh -all -update
#fi
echo "<--- End at "`date '+%H:%M:%S'`

##############
# Performances
##############
echo " "
echo "########################"
echo "# Test the performance #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S'`
total=0
machines=`liste_machines "\-benchmark" | $TRUST_Awk -F. '{print $1}'`
echo "Validation by -benchmarck on"
echo $machines
nb_machines=0
for machine in $machines
do
   PERF=`ls $REP_NUIT/PERF_TRUST_*$machine 2>/dev/null`  
   echo "  Analysis of "$PERF" file"
   if [ -f "$PERF" ] && [ "`grep Run_bench $PERF`" != "" ]
   then
      # Aucune efficacite en dessous de 0.60 sur 4 processeurs et aucun cpu au dessus de 8s sur 1 processeur:
      perf=`$TRUST_Awk 'BEGIN {p=0} ($1==4) && (NF==12) && /\|/ {if ($(NF-1)>0.60) p=p+0.25} ($1==1) && (NF==12) && /\|/ {if ($3<8) p=p+0.25} END {print p}' $PERF`
      total=`echo "$total+$perf" | bc -l`
      echo "Time VDF and VEF on 1 CPU: < 8s ?"
      $TRUST_Awk '($1==1) && (NF==12) && /\|/ {print $3}' $PERF
      echo "Speed-UP VDF and VEF on 4 CPUs: > 0.60 ?"
      $TRUST_Awk '($1==4) && (NF==12) && /\|/ {print $(NF-1)}' $PERF
      echo "=> perf+=$perf (total=$total)"  
      let nb_machines=$nb_machines+1
      [ $(echo " $perf < 1 " | bc) -eq 1 ] && cat $PERF | mail_ -s\"[lance_test_nuit] Benchmark on $machine KO\" $TRUST_MAIL
   else
      echo "File not exist => benchmark not executed on the machine: $machine"
   fi
done
echo "Call to $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/src/Run_fiche"
bench_log=$REP_NUIT"/benchmark_report_"$HOST".log"
echo "  See $bench_log"
echo "TRUST benchmarh report on $HOST the `date` ...">$bench_log
echo>>$bench_log
rm -f $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf
(cd $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport;rm -f Run.log;Run_fiche 1>>$bench_log 2>&1)
tail -n1 $bench_log
if [ -f $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf ]
then
   if [ "`date '+%u'`" = 6 ]
   then
      echo "$TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/src/Run_fiche" | mail_ -a\"$TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TRUST_MAIL $TRUST_PROJECT_LEADER
   else
      echo "$TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/src/Run_fiche" | mail_ -a\"$TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/build/rapport.pdf\" -s\"[lance_test_nuit] Benchmark report generated `date '+%d/%m/%y'`\" $TRUST_MAIL
   fi
else
   cat $TRUST_ROOT/tests/Reference/BENCHMARK/Rapport/Run.log | mail_ -s\"[lance_test_nuit] KO Benchmark report NOT generated `date '+%d/%m/%y'`\" $TRUST_MAIL
fi
#nb_machines=`echo $machines | $TRUST_Awk '{print NF}'`
performances=0 && [ $total = $nb_machines ] && [ $total != 0 ] && performances=1
echo " "
if [ "$performances" = 1 ]
then
   echo "Release criterion: Performance OK"
else
   echo "Release criterion: Performance KO"
fi
force_performances=~/force_performances && [ -f $force_performances ] && performances=1 && rm -f $force_performances
[ "$nb_machines" -eq 0 ] && nb_machines=-1
echo "$performances  Performance $total/$nb_machines="`echo "$total/$nb_machines" | bc`" (=1)" >> $MESSAGES_NUIT
[ "$nb_machines" -eq -1 ] && nb_machines=0
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$performances
echo "<--- End at "`date '+%H:%M:%S'`

###########
# ToDo list
###########
echo " "
echo "########################"
echo "# Verify the ToDo list #"
echo "########################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $TRUST_ROOT/ToDo file"
echo `grep -c ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`" requests to do before the release of the next version"
nothing_todo=0 && [ "`grep ${TRUST_VERSION%_beta} $TRUST_ROOT/ToDo`" = "" ] && nothing_todo=1
# Envoi aux personnes concernees
for qui in `$TRUST_Awk '!/Qui/ {print $2}' $TRUST_ROOT/ToDo | sort -u`
do
   grep $qui $TRUST_ROOT/ToDo | grep ${TRUST_VERSION%_beta} > $TRUST_TMP/ToDo
   [ -s $TRUST_TMP/ToDo ] && [ "`date '+%u'`" = 6 ] && cat $TRUST_TMP/ToDo | mail_ -s \"[lance_test_nuit] ToDo list for the version ${TRUST_VERSION%_beta}\" $qui
done
# Envoi tous les samedis au chef de projet pour planning debut de semaine
[ "`date '+%u'`" = 6 ] && cat $TRUST_ROOT/ToDo | mail_ -s \"[lance_test_nuit] ToDo list for the version ${TRUST_VERSION%_beta}\" $TRUST_PROJECT_LEADER $TRUST_TODO_MAIL
#
echo " "
if [ "$nothing_todo" = 1 ]
then
   echo "Release criterion: ToDo OK"
else
   echo "Release criterion: ToDo KO"
fi
echo "$nothing_todo  ToDo $nothing_todo (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$nothing_todo
echo "<--- End at "`date '+%H:%M:%S'`

########
# Etudes
########
echo " "
echo "#####################################"
echo "# Verify the results of study cases #"
echo "#####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $REP_NUIT/run_Etudes.log file"
OK=`grep "OK Studies" $REP_NUIT/run*.log 2>/dev/null | wc -l`
KO=`grep "KO Studies" $REP_NUIT/run*.log 2>/dev/null | wc -l`
let NB=$OK+$KO
echo "  $OK/$NB studies verified"
[ "$NB" -eq 0 ] && NB=-1 
validation_etudes=0 && [ $OK = $NB ] && validation_etudes=1
echo " "
if [ "$validation_etudes" = 1 ]
then
   echo "Release criterion: Studies OK"
else
   echo "Release criterion: Studies KO"
   #[ "$NB" -gt 0 ] && cat $REP_NUIT/run_Etudes.log | mail_ -s \"[lance_test_nuit] Results of study cases KO\" $TRUST_MAIL
   cat $REP_NUIT/run_Etudes.log | mail_ -s \"[lance_test_nuit] Results of study cases KO\" $TRUST_MAIL
fi
force_validation_etudes=~/force_validation_etudes && [ -f $force_validation_etudes ] && validation_etudes=1 && rm -f $force_validation_etudes
if [ "$NB" -eq -1 ]
then
  echo "$validation_etudes  Studies $OK/0="`echo "$OK/$NB" | bc`" (=1)" >> $MESSAGES_NUIT
  NB=0
else
  echo "$validation_etudes  Studies $OK/$NB="`echo "$OK/$NB" | bc`" (=1)" >> $MESSAGES_NUIT
fi
[ "$NB" -eq -1 ] && NB=0 
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_etudes
echo "<--- End at "`date '+%H:%M:%S'`

###########################################
# PROJETS BALTIK BASES SUR LE KERNEL ONLY #
###########################################
echo " "
echo "#########################################"
echo "# Test the portability of baltik MPCube #"
echo "#########################################"
echo "---> Begin at "`date '+%H:%M:%S'`
# Voir si dans le futur on ne peut pas faire converger la procedure check_components sur
# les projets Baltik place sous la VOBS Composants et ce projet Baltik.
PROJECT_ROOT=$WORKDIR/MPCube/mpcube-portage166	# MPCube a porter pour 1.6.2
#log=$PROJECT_ROOT/check_baltik_project.log
log=$REP_NUIT"/baltik_MPCube_"$HOST"_Kernel.log"
# Necessaire de mettre entre () car initialisation du projet Baltik
(
source $WORKDIR/git/Kernel/TRUST/env/env_TRUST.sh 1>/dev/null 2>&1
cd $PROJECT_ROOT
echo "Call to $WORKDIR/git/Kernel/TRUST/bin/admin/check_baltik_project"
echo "from `pwd`"
echo "  See $log"
echo "MPCube project baltik check on $HOST the `date` ...">$log
echo>>$log
$WORKDIR/git/Kernel/TRUST/bin/admin/check_baltik_project 1>>$log 2>&1
grep 'Projet Baltik' $log | grep OK
cd - 1>/dev/null 2>&1
)
if [ "`grep 'Projet Baltik' $log | grep OK`" != "" ]
then
   validation_projets_baltik=1
else
   validation_projets_baltik=0
   cat $log | mail_ -s \"[lance_test_nuit] Portability KO on Baltik $PROJECT_ROOT\" $TRUST_MAIL $TRUST_PROJECT_LEADER
fi
echo " "
if [ "$validation_projets_baltik" = 1 ]
then
   echo "Release criterion: MPCube OK"
else
   echo "Release criterion: MPCube KO"
fi
echo "$validation_projets_baltik  MPCube $validation_projets_baltik (=1) Baltik=$PROJECT_ROOT" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_projets_baltik
echo "<--- End at "`date '+%H:%M:%S'`

##########
# PROJETS
##########
force_composant=~/force_composant
for Composant in $Composants
do
   echo " "
   echo "###################################"
   echo "# Verify the portability of baltik $Composant "
   echo "###################################"
   echo "---> Begin at "`date '+%H:%M:%S'`
   PROJECT_ROOT=`dirname $TRUST_ROOT`/Composants/$Composant
   # Check if component is OK on $HOST:
   #Composant_log=$PROJECT_ROOT.log
   Composant_log=$REP_NUIT"/baltik_"$Composant"_"$HOST"_Livraison.log"
   echo "Analysis of  $PROJECT_ROOT/*.log files"
   validation_composant=0 && [ "`grep "$Composant OK" $Composant_log`" != "" ] && validation_composant=1
   grep "$Composant OK" $Composant_log | sed '1d'  
   grep KO $PROJECT_ROOT/*.log | grep Info_global
   # Check if portability is OK:
   # if [ "`grep " Error" $PROJECT_ROOT/*.log 2>/dev/null`" != "" ]
   if [ "`grep KO $PROJECT_ROOT/*.log | grep Info_global 2>/dev/null`" != "" ]
   then
      validation_composant=0
      echo "Run: konqueror $PROJECT_ROOT/nuit_$Composant.html"
      echo "Run: konqueror $PROJECT_ROOT/nuit_$Composant.html" | mail_ -s \"[lance_test_nuit] Portability KO on Baltik $Composant\" $TRUST_MAIL
   fi
   echo " "
   if [ "$validation_composant" = 1 ]
   then
      echo "Release criterion: $Composant OK"
   else
      echo "Release criterion: $Composant KO"
   fi
   [ -f $force_composant ] && validation_composant=1
   echo "$validation_composant  $Composant $validation_composant (=1) Baltik=$PROJECT_ROOT" >> $MESSAGES_NUIT
   let total_criteres=$total_criteres+1
   let criteres_remplis=$criteres_remplis+$validation_composant
   echo "<--- End at "`date '+%H:%M:%S'`
done
rm -f $force_composant

####################
# SCRIPTS IMPORTANTS
####################
echo " "
echo "####################################"
echo "# Verify the validation of scripts #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Analysis of $REP_NUIT/CR_* files"
grep Script $REP_NUIT/CR_* | grep KO
validation_scripts=0
if [ "`grep Script $REP_NUIT/CR_* | grep KO`" = "" ]
then
   validation_scripts=1
else
   grep Script $REP_NUIT/CR_* | grep KO | mail_ -s\"[lance_test_nuit] Validation of scripts KO\" $TRUST_MAIL
fi
echo " "
if [ "$validation_scripts" = 1 ]
then
   echo "Release criterion: Scripts OK"
else
   echo "Release criterion: Scripts KO"
fi
force_validation_scripts=~/force_validation_scripts && [ -f $force_validation_scripts ] && validation_scripts=1 && rm -f $force_validation_scripts
echo "$validation_scripts  Scripts $validation_scripts (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_scripts
echo "<--- End at "`date '+%H:%M:%S'`

#########
# Doxygen
#########
echo " "
echo "####################################"
echo "# Verify the Doxygen documentation #"
echo "####################################"
echo "---> Begin at "`date '+%H:%M:%S'`
echo "Search of $TRUST_ROOT/doc/doxygen*.err file"
[ -f $TRUST_ROOT/doc/doxygen*.err ] && ls -la $TRUST_ROOT/doc/doxygen*.err
validation_doxygen=1 && [ -s $TRUST_ROOT/doc/doxygen*.err ] && validation_doxygen=0 && cat $TRUST_ROOT/doc/doxygen*.err | mail_ -s\"[lance_test_nuit] Validation of Doxygen documentation KO\" $TRUST_MAIL #$TRUST_PROJECT_LEADER
echo " "
if [ "$validation_doxygen" = 1 ]
then
   echo "Release criterion: Doxygen OK"
else
   echo "Release criterion: Doxygen KO"
fi
echo "$validation_doxygen  Doxygen $validation_doxygen (=1)" >> $MESSAGES_NUIT
let total_criteres=$total_criteres+1
let criteres_remplis=$criteres_remplis+$validation_doxygen
echo "<--- End at "`date '+%H:%M:%S'`

echo "Total: $criteres_remplis/$total_criteres criteria for the $new version" >> $MESSAGES_NUIT
echo "-------------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
#
#
#
echo " "
echo "------------------------------------------------------"
echo " "
echo "##############################"
echo "# Deliver and export version #"
echo "##############################"
echo " "
echo "###########################"
echo "# Test if Release version #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S'`

########################################################################
# Feu vert de l'administrateur TRUST d'apres l'en tete de RELEASE_NOTES
########################################################################
echo "Analysis of $TRUST_ROOT/RELEASE_NOTES file"
export accord_admin=0 && [ ${new%_beta} = $new ] && accord_admin=1
label=v${new%_beta}
deja_livre=0
if [ "$accord_admin" = 1 ]
then
   echo ${new%_beta}" == "$new" => agreement_administrator = "$accord_admin
   # Commit
   echo "Call git commit --u=no --all -m Commit before the $new version."
   git commit --u=no --all -m"Commit before the $new version."
else
   echo ${new%_beta}" >< "$new" => agreement_administrator = "$accord_admin
fi

####################################################################################################
# Si un certain nombre de criteres sont remplis, on propose une release (candidate ou intermediaire)
# Tous les jours si accord_admin = 1, label_rc=X.Y.Z_rc
# Le samedi seulement si accord_admin = 0, label_rc=X.Y.Z_beta
####################################################################################################
echo " "
echo "Analysis of $MESSAGES_NUIT file"
grep "Total:" $MESSAGES_NUIT
echo "  criteria:  "$criteres_remplis" != "$total_criteres
echo "  minimum:   "$criteres_remplis" -ge 11"
echo "  stability: "$stabilite" = 1.000"
if [ $criteres_remplis != $total_criteres ] && [ $criteres_remplis -ge 11 ] && [ $stabilite = "1.000" ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   # if [ $accord_admin = 1 ] || [ "`date '+%u'`" > 0 ]
   if [ $accord_admin = 1 ] || [ "`date '+%u'`" = 6 ]
   then
      # On decide du nom du label specifique
      label_rc=$label"_rc" && release=candidate && [ $accord_admin = 0 ] && label_rc=$label"_beta" && release=beta
      echo " with label "$label_rc
      echo " "
      error_rc=0
      
      # Commit
      numero=`git tag | grep $label_rc | wc -l` && [ "$numero" = "" ] && numero=0
      let numero=$numero+1
      label_pose=$label_rc$numero 
      echo "  Call git commit --all -m Commit for a Release $release $label_pose version"
      git commit --all -m"Commit for a Release $release $label_pose version."
      # On pose le tag:
      echo "  Call git tag $label_pose"
      git tag $label_pose
      # Push
      echo "  Call git push"
      git_push
 
      if [ $error_rc = 0 ]
      then  
         # On previent l'administrateur et le project leader
         cat $TRUST_ROOT/RELEASE_NOTES | mail_ -s\"[lance_test_nuit] Release version - Tag a $release version: $label_pose\" $TRUST_MAIL $TRUST_PROJECT_LEADER
      fi
      echo " "
      echo "Release of the $release version: $label_pose"
      echo "New version $label_pose : Not delivery" >> $MESSAGES_NUIT
   else
      echo " without label"
   fi
else
   if [ $criteres_remplis != $total_criteres ]
   then
     echo "=> release KO"
     if [ $accord_admin = 1 ]
     then
        echo "New version $label : Not delivery because only $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     else
        echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
     fi
   fi
fi

#############################################################
# Si tous les criteres sont remplis, on tamponne la version !
#############################################################
export livraison=0
if [ $criteres_remplis = $total_criteres ]
then
   echo "Version $new : Currently $criteres_remplis criteria are OK on $total_criteres planned" >> $MESSAGES_NUIT
   echo -e "=> release OK\c"
   if [ $accord_admin = 0 ]
   then
      [ $deja_livre = 0 ] && echo "New version $label : Delivery possible if agreement of $TRUST_MAIL" >> $MESSAGES_NUIT
      [ $deja_livre = 1 ] && echo "New version $label : Delivery already made" >> $MESSAGES_NUIT
   else
      echo " with label "$label
      echo " "
      # Checkin et verification que tous les fichiers sont checkines
      erreur_checkin=""
      # Track again all files which were --assume-unchanged before:
      cd $TRUST_ROOT/..
      echo "  Call git update-index --no-assume-unchanged"
      for unchanged in `git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'`
      do
         git update-index --no-assume-unchanged $unchanged
      done
      cd - 1>/dev/null 2>&1
      # Commit & Push
      echo "  Call git commit --all -m Commit for an official Release $label version."
      git commit --all -m"Commit for an official Release $label version."
      echo "  Call git push"
      git_push -all
      if [ "$erreur_checkin" != "" ]
      then
         echo "New version $label : Delivery canceled because some files could not be checkined: $erreur_checkin" >> $MESSAGES_NUIT
      else
	 echo "New version $label : Delivery in progress..." >> $MESSAGES_NUIT
	 livraison=1
	 echo "  Call git tag $label at "`date '+%H:%M:%S'`
         git tag $label
	 echo " "
	 echo "Changing the Maintenance view"	 
	 # Changement de la vue Maintenance
	 (
	    cd $WORKDIR/git/Maintenance/TRUST
	    echo "from `pwd`"
            patch_old=patch_`echo $old | $TRUST_Awk '{gsub("\\\.","",$0);print $0}'`
	    patch_new=patch_`echo $new | $TRUST_Awk '{gsub("\\\.","",$0);print $0}'`
	    echo "  Call git fetch --all"
            git fetch --all # Pour recuperer tous les tags
            # Creation de la branche depuis le tag (example: patch_XYZ depuis vX.Y.Z)
            git checkout -b $patch_new $label
            # Positionnement de HEAD sur la branche (exemple: patch_XYZ)
	    echo "  Call git symbolic-ref HEAD refs/heads/$patch_new"
            git symbolic-ref HEAD refs/heads/$patch_new
            # Push
	    echo "  Call git push"
            git_push -all
            # Le repo officiel pointe desormais sur la branche (exemple: patch_XYZ)
	    echo "  Update $TRUST_GIT_REPOS repos on $TRUST_GIT_SERVER server"
            ssh triou@$TRUST_GIT_SERVER -n 'cd '$TRUST_GIT_REPOS';git symbolic-ref HEAD refs/heads/'$patch_new
	 )
	 echo " "
	 echo "Creation of the packages of each Baltik component"
	 # Creation des packages de chaque composant BALTIK
	 cd $WORKDIR/git/Livraison/TRUST
	 source env/env_TRUST.sh 1>/dev/null 2>&1
	 for Composant in $Composants 
	 do
	    # Appel du make distrib
	    cd $WORKDIR/git/Livraison/Composants/$Composant
	    echo "from `pwd`"
	    echo "  Call make distrib"
	    make distrib
	    mkdir -p $WORKDIR/A_GRAVER_CD_$Composant
	    echo "  Copy $Composant.tar.gz to $WORKDIR/A_GRAVER_CD_$Composant/$Composant-$new.tar.gz"
	    cp -f $Composant.tar.gz $WORKDIR/A_GRAVER_CD_$Composant/$Composant-$new.tar.gz
	    echo | mail_ -s\"[lance_test_nuit] $Composant v$new is released under $WORKDIR/A_GRAVER_CD_$Composant\" $TRUST_MAIL
	 done
	 echo "Version $new : ...End" >> $MESSAGES_NUIT
         echo " "
         echo "Creation of the Stable version: $label"
      fi
   fi
fi
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo `date` >> $MESSAGES_NUIT
echo "----------------------------------------------------------------------------------------" >> $MESSAGES_NUIT
echo "<--- End at "`date '+%H:%M:%S'`



####################################
# Envoi des binaires et des versions
####################################
echo " "
echo "####################"
echo "# Send to ftp site #"
echo "####################"
echo "---> Begin at "`date '+%H:%M:%S'`
envoie_ftp_log=$REP_NUIT/envoie_ftp_cea_fr_$HOST.log
echo "Call to "$TRUST_ROOT"/bin/admin/envoie_ftp_cea_fr"
echo "  See $envoie_ftp_log"
echo "TRUST script on $HOST the `date` ...">$envoie_ftp_log
echo>>$envoie_ftp_log
envoie_ftp_cea_fr 1>>$envoie_ftp_log 2>&1
grep -i killed $envoie_ftp_log
grep -i Error $envoie_ftp_log
grep KO $envoie_ftp_log

#####################################
# Mises a jour diverses de $TRUST_FTP
#####################################
cd $TRUST_TMP
# Update the index.html file of the FTP site:
echo " "
echo "Call to "$TRUST_ROOT"/bin/admin/cree_index.html"
echo "from `pwd`"
cree_index.html
echo "<--- End at "`date '+%H:%M:%S'`

#-------------------------------------------------------
echo " "
echo "###########################"
echo "# Send announcements mail #"
echo "###########################"
echo "---> Begin at "`date '+%H:%M:%S'`

################################################################################################
# Le mail des RELEASES NOTES est envoye aux developpeurs tous les mardis ou lors de la livraison
# sinon uniquement a l'admin TRUST et au chef de projet
################################################################################################
if [ "`date '+%u'`" = 2 ] || [ $livraison = 1 ]
then
   ALL_DEVELOPERS_TRUST_MAIL=trio_u_dev@saxifrage.saclay.cea.fr
else
   ALL_DEVELOPERS_TRUST_MAIL=$TRUST_MAIL" "$TRUST_PROJECT_LEADER
fi

#####################################
# Envoi d'un message aux developpeurs
#####################################
cd $TRUST_ROOT/exec
for dest in $ALL_DEVELOPERS_TRUST_MAIL
do
   if [ $livraison = 0 ]
   then
      echo "$MESSAGES_NUIT sent to $dest"
      mail_ -s \"[Diffusion list dev TRUST] Release criteria of TRUST $new on `date '+%d/%m/%y'`\" $dest < $MESSAGES_NUIT
   else
      patch_old=patch_`echo $old | $TRUST_Awk '{gsub("\\\.","",$0);print $0}'`
      patch_new=patch_`echo $new | $TRUST_Awk '{gsub("\\\.","",$0);print $0}'`
   fi
done

############################################################################
# Annonce d'une version stable a tout le monde (developpeur et utilisateurs)
############################################################################
ALL_USERS_TRUST_MAIL=trio_u_annonces@saxifrage.saclay.cea.fr
if [ $livraison = 1 ]
then
   echo | mail_ -s \"[lance_test_nuit] WARNING! TRUST v$new released: Check that the data of FTP site is correct...\" $TRUST_MAIL
   for dest in $ALL_USERS_TRUST_MAIL" "$ALL_DEVELOPERS_TRUST_MAIL
   do
      echo "Stable release announcement sent to $dest"
      mail_ -s \"TRUST v$new released\" $dest << EOF
New TRUST version released (v$new).
Look at ftp://$TRUST_FTP/$PUBLIC/index.html
to read the release notes or to download TRUST distribution.
Please, do not give the ftp address without permission.

TRUST support team. mailto:$TRUST_MAIL

To unsubscribe: Reply to this message.
EOF
      sleep 5
   done   
   ########################################################
   # On change les NOTES en augmentant le numero de version
   # car sinon on risque des ennuis le lendemain (Version1.5.3.tar+cle effaces dans A_GRAVER_CD_TRUST)
   echo " "
   echo "Call CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES"
   CHECKOUT $TRUST_ROOT/RELEASE_NOTES $TRUST_ROOT/DEVELOPER_NOTES
   next_new=`echo $new | $TRUST_Awk -F"." '{if (NF==3) print $1"."$2"."$3+1"_beta";else if (NF==2) print $1"."$2".1_beta"}'`
   echo "--------------------------------------------------------------------------------------------------
Release notes version $next_new : Enhancements, modifications and corrected bugs since version $new :
--------------------------------------------------------------------------------------------------

" > $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_ROOT/RELEASE_NOTES >> $TRUST_TMP/RELEASE_NOTES
   cat $TRUST_TMP/RELEASE_NOTES > $TRUST_ROOT/RELEASE_NOTES
   echo "-------------------------------------------------------------
Developer notes version $next_new : Changes since version $new :
-------------------------------------------------------------

" > $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_ROOT/DEVELOPER_NOTES >> $TRUST_TMP/DEVELOPER_NOTES
   cat $TRUST_TMP/DEVELOPER_NOTES > $TRUST_ROOT/DEVELOPER_NOTES  
   # Commit immediately to differenciate master and patch branchs for setting the correct default branch after git clone
   # See http://git.661346.n2.nabble.com/git-clone-not-getting-the-correct-default-branch-td7476876.html
   echo " "
   echo "Call git commit --all"
   git commit --all -m"First automatic commit"
   cd $TRUST_ROOT
   ################################################
   # Installation a distance sur plusieurs machines
   ################################################
   echo " "
   echo "Call to "$TRUST_ROOT"/bin/admin/Installer_TRUST.ssh on:"
   liste_machines updated
   for machine in `liste_machines updated`
   do
      (
       install_stable_log=$REP_NUIT"/install_stable_"$machine".log"
       echo "-> Start of Installer_TRUST.ssh $machine $new -compile..."
       echo "  See $install_stable_log"
      )
   done
   for machine in `liste_machines updated`
   do
      Installer_TRUST.ssh $machine $new -compile 1>$install_stable_log 2>&1 &
   done
   wait
   echo " "
fi
echo `echo ~`"/CR sent to $TRUST_MAIL"
#mail_ -s \"[lance_test_nuit] Night report of TRUST workshop  on `date '+%d/%m/%y'`\" $TRUST_MAIL < ~/CR
echo "<--- End at "`date '+%H:%M:%S'`

echo " "
echo "****************************************************"
echo "End of the `basename $0` script at `date '+%H:%M:%S'`."
echo `date`
echo "****************************************************"

mail_ -s \"[lance_test_nuit] Night report of TRUST workshop  on `date '+%d/%m/%y'`\" $TRUST_MAIL < ~/CR
# On deplace le CR
mv -f ~/CR $REP_NUIT/CR
cp -f $REP_NUIT/CR $REP_HIST/CR.$DATE

